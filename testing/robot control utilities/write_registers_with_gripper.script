def unnamed():
  modbus_add_signal("169.254.222.138", 255, 420, 3, "MODBUS_1", False)
  modbus_set_signal_update_frequency("MODBUS_1", 125)
  set_standard_analog_input_domain(0, 1)
  set_standard_analog_input_domain(1, 1)
  set_tool_analog_input_domain(0, 1)
  set_tool_analog_input_domain(1, 1)
  set_analog_outputdomain(0, 0)
  set_analog_outputdomain(1, 0)
  set_tool_voltage(0)
  set_input_actions_to_default()
  modbus_set_runstate_dependent_choice("MODBUS_1",0)
  set_tcp(p[0.0,0.0,0.19,0.0,0.0,0.0])
  set_payload(1.0)
  set_gravity([0.0, 0.0, 9.82])
  # begin: URCap Installation Node
  #   Source: OptoForce Force Torque Sensor, 3.1.1, OptoForce Ltd.
  #   Type: OptoForce Setup
  of_sensor_IP = "10.20.0.15"
  of_robot_type = 3
    #================================================#
    #======    OptoForce Interface Messages    ======#
    #================================================#
  
    OF_DEBUG_GLOBAL=False
    OF_DEBUG_CMD=False
    OF_DEBUG_TX=False
    OF_DEBUG_RX=False
    OF_DEBUG_STATE=False
    OF_DEBUG_VAR=False
    of_ce_comm_error_title="OptoForce - Communication error"
    of_ce_comm_vectorstream_open_error="Socket vectorStream opening was unsuccessful. Ensure that the Compute Box is operational, and check the status in the OptoForce Setup page in the Installation Tab."
    of_ce_comm_vectorstream_packet_error="Socket vectorStream packet error. Ensure that the Compute Box is operational, and check the status in the OptoForce Setup page in the Installation Tab."
    of_ce_comm_commandflow_open_error="Socket commandFlow opening was unsuccessful. Ensure that the Compute Box is operational, and check the status in the OptoForce Setup page in the Installation Tab."
    of_ce_comm_safeguard_lost_error="Connection was lost with the Compute Engine, program stopped. Restart the Compute Box, and check the status in the OptoForce Setup page in the Installation Tab."
    of_ce_comm_cmd_send_error="Command sending to the Compute Box failed. Resending. Command: "
    of_ce_comm_cmd_send_again="Try to send command again.."
    of_ce_comm_int_send_error="Integer sending to the Compute Box failed. Resending. Integer: "
    of_ce_comm_int_send_again="Try to send int again.."
    of_ce_comm_float_send_error="Float sending to the Compute Box failed. Resending. Float: "
    of_ce_comm_float_send_again="Try to send float as int again.."
    of_ce_comm_dummy_send_error="Dummy sending to the Compute Box failed. Resending. [Counter, out of]: "
    of_ce_comm_dummy_send_again="Try to send dummy again.."
    of_ce_comm_controlsocket_open_error="Socket controlSocket opening was unsuccessful. Ensure that the Compute Box is operational, and check the status in the OptoForce Setup page in the Installation Tab."
    of_ce_comm_controlsocket_allocate_error="Port number was not allocated to the script by the robot! Exiting.."
    of_sensor_error_title="OptoForce - Sensor error"
    of_sensor_error_bit0="No sensor connected.<br>Turn off the Compute Box, connect the sensor to the Compute Box with an undamaged cable, turn on the Compute Box. If the error persists, contact your distributor."
    of_sensor_error_bit1="Sensor is not responding.<br>Turn off the Compute Box, connect the sensor to the Compute Box with an undamaged cable, turn on the Compute Box. If the error persists, contact your distributor."
    of_sensor_error_bit2="Sensor failure.<br>Gather information about the situation in which this error occurred, and contact your distributor."
    of_sensor_error_bit3="Sensor power or EEPROM error.<br>Gather information about the situation in which this error occurred, and contact your distributor, or OptoForce."
    of_sensor_error_bit4="Communication error between the sensor and the Compute Box.<br>Turn off the Compute Box, connect the sensor to the Compute Box with an undamaged cable, turn on the Compute Box. If the error persists, contact your distributor."
    of_sensor_error_bit5="Sensor force overload error.<br>Eliminate the circumstances that cause the sensor to be overloaded, that is, offload the sensor."
    of_sensor_error_bit6="Sensor torque overload error.<br>Eliminate the circumstances that cause the sensor to be overloaded, that is, offload the sensor."
    of_sensor_error_bit7="Sensor error.<br>Contact your distributor."
    of_sensor_error_else="Unknown sensor error(s).<br>Connect to the Compute Box Web Access, and analize the STATUS word. Refer to the Compute Box Description on the OptoForce USB drive."
    of_cmd_error_title="OptoForce - Command error"
    of_ft_control_start_error="Do not include a F/T Control command under another F/T Control command."
    of_move_error_title="OptoForce - F/T Move error"
    of_search_error_title="OptoForce - F/T Search error"
    of_move_init_error="Wrong F/T Move or F/T Search status when initializing.<br>Another thread is using an F/T Move or F/T Search command. Program stopped."
    of_move_start_error="Wrong F/T Move or F/T Search status when starting.<br>Another thread is using an F/T Move or F/T Search command. Program stopped."
    of_move_return_error="Wrong F/T Move or F/T Search status when returning.<br>Another thread is using an F/T Move or F/T Search command. Program stopped."
    of_move_parameter_error_coordsys="Parameter error.<br>Unknown coordinate system. Program stopped."
    of_move_parameter_error_speed="Parameter error.<br>Invalid value for the speed parameter. Program stopped."
    of_move_parameter_error_acc="Parameter error.<br>Invalid value for the acc parameter. Program stopped."
    of_move_parameter_error_count="Parameter error.<br>Incorrect use of F/T Waypoint or F/T Path in the F/T Move or F/T Search command. Program stopped."
    of_move_move_return_title="OptoForce - F/T Move"
    of_move_move_return_0="The move ended without detecting a force or torque greater than the set limit."
    of_move_move_return_1="The move ended, because a force or torque greater than the set limit was detected."
    of_move_move_return_3="The move was interrupted by a command."
    of_move_move_return_11="The move cannot start, because there is no recorded path on the Compute Box with the selected ID."
    of_move_move_return_12="The move cannot start, because there are no recorded points in this Path."
    of_move_move_return_13="The move cannot start, because the Path file found at this Path ID is empty."
    of_move_move_return_14="The move cannot start, because the Path file is corrupted."
    of_move_move_return_unknown="F/T Move finished with unknown return value."
    of_move_search_return_title="OptoForce - F/T Search"
    of_move_search_return_0="The search ended successfully, because a force or torque greater than the set limit was detected."
    of_move_search_return_1="The search ended without detecting a force or torque greater than the set limit."
    of_move_search_return_3="The search was interrupted by a command."
    of_move_search_return_11="The search cannot start, because there is no recorded path on the Compute Box with the selected ID."
    of_move_search_return_12="The search cannot start, because there are no recorded points in this Path."
    of_move_search_return_13="The search cannot start, because the Path file found at this Path ID is empty."
    of_move_search_return_14="The search cannot start, because the Path file is corrupted."
    of_move_search_return_unknown="F/T Search finished with unknown return value."
    of_waypoint_error_title="OptoForce - F/T Waypoint error"
    of_waypoint_move_state_error="Wrong program structure when initializing F/T Waypoint.<br>Program stopped.<br>Make sure that the F/T Waypoint is under F/T Move or F/T Search."
    of_waypoint_path_count_error="Incorrect use of F/T Waypoint.<br>Do not use F/T Waypoint and F/T Path in the same F/T Move or F/T Search.<br>Program stopped."
    of_waypoint_parameter_error_target="Parameter error.<br>Please define a valid target pose or relative movement."
    of_waypoint_parameter_error_frame="Parameter error.<br>Unknown coordinate system."
    of_waypoint_parameter_error_close="Parameter error.<br>The given pose is too close to the last one. Program stopped."
    of_path_error_title="OptoForce - F/T Path error"
    of_path_move_state_error="Wrong program structure when initializing F/T Path.<br>Program stopped.<br>Make sure that the F/T Path is under F/T Move or F/T Search."
    of_path_path_count_error=" Incorrect use of F/T Path.<br>Do not use multiple F/T Paths in the same F/T Move or F/T Search.<br>Program stopped."
    of_path_wp_count_error=" Incorrect use of F/T Path.<br>Do not use F/T Waypoint and F/T Path in the same F/T Move or F/T Search.<br>Program stopped."
    of_path_parameter_error_pathid="Parameter error.<br>Invalid F/T Path ID."
    of_hand_guide_title="OptoForce - Hand Guide"
    of_hand_guide_error_high_ft="Too high forces. Hand Guide stopped."
    of_hand_guide_error_singularity="The tool flange is too close to a singularity. Hand Guide stopped."
    of_hand_guide_safemode_enter="The tool flange is too close to the Base Z-axis singularity. Hand Guide is in Safe mode."
    of_hand_guide_safemode_exit="Hand Guide Safe mode ended."
  
    #=======================================================#
    #======    End of OptoForce Interface Messages    ======#
    #=======================================================#
  
    #================================================#
    #======    Start of OptoForce Interface    ======#
    #================================================#
  
    global Fx=0
    global Fy=0
    global Fz=0
    global Tx=0
    global Ty=0
    global Tz=0
    global F3D=0
    global T3D=0
    global bFT=[0,0,0,0,0,0]
    global tFT=[0,0,0,0,0,0]
    global of_return=0
    global of_compute_engine_ping=0
    global of_compute_engine_ping_max=0
    ZEROPOSE=p[0,0,0,0,0,0]
    ZEROFRAME=p[0,0,0,0,0,0]
    FALSE6D=[False,False,False,False,False,False]
    FALSE8D=[False,False,False,False,False,False,False,False]
    of_compute_engine_IP=""
    OF_APP_ENGINE_PORT=0
    OF_COMMAND_PORT=0
    OF_VECTOR_STREAM_PORT=0
    of_v2r_received=0
    of_cmd_received=0
    of_sg_count=0
    sFT=[0.0,0.0,0.0,0.0,0.0,0.0]
    of_TCP_offset=ZEROFRAME
    of_pn_data=[0,0,0]
    of_appvect=[0.0,0.0,0.0,0.0,0.0,0.0,0.0]
    of_dataAVFT=[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]
    of_data=[0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0]
    of_sensor_status=0
    of_cmd_rx=[0,0,0]
    of_ack_received=False
    of_speedl_thread_handler=0
    of_speedl_is_running=False
    of_speedl_acc=0
    of_speedl_for_limit=False
    of_speedl_for_ftcontrol=False
    of_speedl_for_move=False
    of_speedl_for_handguide=False
    of_limit_return=0
    of_ft_control_return=0
    of_move_return=0
    of_path_return=0
    of_ft_control_state=0
    of_move_state=0
    of_hg_caranteen_reached=False
    of_hg_caranteen_safemode=False
    of_hg_enable_axes=FALSE6D
    of_hg_axisZ_extra_dist=0
    of_hg_axisZ_min_dist=0
    of_hg_axisZ_dist=0
    of_hg_TMB_dist=0
    of_hg_joints_min_dev=0
    of_hg_stop_F=0
    of_hg_stop_T=0
    of_move_frameID=0
    of_move_frame=ZEROFRAME
    of_move_parent_frameID=0
    of_move_parent_frame=ZEROFRAME
    of_move_last_pose=ZEROPOSE
    of_move_min_dist=0
    of_move_wp_count=0
    of_move_path_count=0
    of_move_path_move_home=False
    of_portopened_vectorStream=False
    of_portopened_commandFlow=False
    of_portopened_controlSocket=False
    OF_APP_ENGINE_PING_LIMIT=19
    OF_APP_ENGINE_PORT=51234
    OF_COMMAND_PORT=OF_APP_ENGINE_PORT
    OF_VECTOR_STREAM_PORT=OF_APP_ENGINE_PORT+1
    OF_SCALE_FLOAT=1000000
    of_speedl_acc=10000.0
    of_move_min_dist=0.001
    of_hg_joints_min_dev=d2r(0.5)
    of_hg_axisZ_extra_dist=0.06
    if of_robot_type==10:
    if OF_DEBUG_STATE:
    textmsg("Robot type UR10 set")
    end
    of_hg_axisZ_min_dist=0.163941
    of_hg_TMB_dist=0.0922
    elif of_robot_type==5:
    if OF_DEBUG_STATE:
    textmsg("Robot type UR5 set")
    end
    of_hg_axisZ_min_dist=0.10915
    of_hg_TMB_dist=0.0823
    elif of_robot_type==3:
    if OF_DEBUG_STATE:
    textmsg("Robot type UR3 set")
    end
    of_hg_axisZ_min_dist=0.11235
    of_hg_TMB_dist=0.0819
    elif of_robot_type==0:
    if OF_DEBUG_STATE:
    textmsg("Robot type not set: do not use caranteen")
    end
    of_hg_axisZ_min_dist=0
    of_hg_TMB_dist=0.0
    else:
    if OF_DEBUG_STATE:
    textmsg("Unknown robot type, using UR10 parameters; Type: ",of_robot_type)
    end
    of_hg_axisZ_min_dist=0.163941
    of_hg_TMB_dist=0.0922
    end
    of_hg_axisZ_dist=of_hg_axisZ_min_dist+of_hg_axisZ_extra_dist
    OF_CMD_ACK=0
    OF_CMD_STOP=1
    OF_CMD_START=2
    OF_CMD_BIAS=3
    OF_CMD_TCP=4
    OF_CMD_SENSOR_CONFIG=5
    OF_CMD_COG=6
    OF_CMD_LIMIT=7
    OF_CMD_FT_CONTROL=8
    OF_CMD_HAND_GUIDE=9
    OF_CMD_MOVE=10
    OF_CMD_WAYPOINT=11
    OF_CMD_PATH=12
    OF_CMD_DIO=13
    OF_CMD_AIO=14
    OF_CMD_TX_PARAM_LENGTH=20
    OF_DUMMY_VALUE=-1
    OF_FT_CONTROL_STATE_IDLE=0
    OF_FT_CONTROL_STATE_RUNNING=1
    OF_MOVE_STATE_IDLE=0
    OF_MOVE_STATE_INIT=1
    OF_MOVE_STATE_GLOBALS_SET=2
    OF_MOVE_STATE_PARAM_SEND=3
    OF_MOVE_STATE_PARAM_SENT=4
    OF_MOVE_STATE_INITED=5
    OF_MOVE_STATE_STARTING=6
    OF_MOVE_STATE_WP_SENT=7
    OF_MOVE_STATE_STARTED=8
    OF_MOVE_STATE_RETURNING=9
    OF_MOVE_STATE_FINISHED=10
    OF_MOVE_STATE_STOPPING=11
    OF_MOVE_STATE_PATH_STOPPED=12
    def of_float_to_int(value):
    if value>(2147483647/OF_SCALE_FLOAT):
    textmsg("Float to int overflow!",value)
    value=2147483647/OF_SCALE_FLOAT
    elif value<(-2147483648/OF_SCALE_FLOAT):
    textmsg("Float to int underflow!",value)
    value=-2147483648/OF_SCALE_FLOAT
    end
    return value*OF_SCALE_FLOAT
    end
    def of_int_to_float(value):
    return value/OF_SCALE_FLOAT
    end
    def of_wait_ms(time_ms):
    local sync_time=norm(time_ms/8.0)
    while(sync_time>0):
    sync_time=sync_time-1
    sync()
    end
    end
    def of_tcp_offset_calc():
    local act_flange=get_actual_tool_flange_pose()
    local act_tcp=get_actual_tcp_pose()
    local tcp_offset=pose_trans(pose_inv(act_flange),act_tcp)
    return tcp_offset
    end
    def of_portclose_vectorStream():
    socket_close("vectorStream")
    of_portopened_vectorStream=False
    end
    def of_portopen_vectorStream():
    of_portclose_vectorStream()
    of_portopened_vectorStream=socket_open(of_compute_engine_IP,OF_VECTOR_STREAM_PORT,"vectorStream")
    if not of_portopened_vectorStream:
    popup(of_ce_comm_vectorstream_open_error,title=of_ce_comm_error_title,error=True,blocking=False)
    halt
    end
    end
    thread of_vectorStream_thread():
    if OF_DEBUG_STATE:
    textmsg("Starting vectorStream thread")
    end
    while of_portopened_vectorStream:
    of_data=socket_read_ascii_float(13,"vectorStream")
    if of_data[0]==13:
    of_dataAVFT=of_data
    of_v2r_received=of_v2r_received+1
    else:
    textmsg("Received: ",of_data)
    popup(of_ce_comm_vectorstream_packet_error,title=of_ce_comm_error_title,error=True,blocking=False)
    halt
    end
    end
    if OF_DEBUG_STATE:
    textmsg("Stopping vectorStream thread")
    end
    end
    thread of_vectorProcess_thread():
    if OF_DEBUG_STATE:
    textmsg("Starting vectorProcess thread")
    end
    while of_portopened_vectorStream:
    sync()
    of_appvect[0]=of_dataAVFT[1]
    of_appvect[1]=of_dataAVFT[2]
    of_appvect[2]=of_dataAVFT[3]
    of_appvect[3]=of_dataAVFT[4]
    of_appvect[4]=of_dataAVFT[5]
    of_appvect[5]=of_dataAVFT[6]
    sFT[0]=of_dataAVFT[7]
    sFT[1]=of_dataAVFT[8]
    sFT[2]=of_dataAVFT[9]
    sFT[3]=of_dataAVFT[10]
    sFT[4]=of_dataAVFT[11]
    sFT[5]=of_dataAVFT[12]
    of_sensor_status=floor(of_dataAVFT[13]+0.5)
    local sensor_status_bits=integer_to_binary_list(of_sensor_status)
    if(of_sensor_status!=0):
    if sensor_status_bits[0]:
    popup(of_sensor_error_bit0,title=of_sensor_error_title,error=True,blocking=False)
    end
    if sensor_status_bits[1]:
    popup(of_sensor_error_bit1,title=of_sensor_error_title,error=True,blocking=False)
    end
    if sensor_status_bits[2]:
    popup(of_sensor_error_bit2,title=of_sensor_error_title,error=True,blocking=False)
    end
    if sensor_status_bits[3]:
    popup(of_sensor_error_bit3,title=of_sensor_error_title,error=True,blocking=False)
    end
    if sensor_status_bits[4]:
    popup(of_sensor_error_bit4,title=of_sensor_error_title,error=True,blocking=False)
    end
    if sensor_status_bits[5]:
    popup(of_sensor_error_bit5,title=of_sensor_error_title,error=True,blocking=False)
    end
    if sensor_status_bits[6]:
    popup(of_sensor_error_bit6,title=of_sensor_error_title,error=True,blocking=False)
    end
    if sensor_status_bits[7]:
    popup(of_sensor_error_bit7,title=of_sensor_error_title,error=True,blocking=False)
    end
    if of_sensor_status>255:
    popup(of_sensor_error_else,title=of_sensor_error_title,error=True,blocking=False)
    end
    textmsg("Sensor error! Error code: ",of_sensor_status)
    halt
    end
    local tcp_transform=of_TCP_offset
    tcp_transform[0]=0
    tcp_transform[1]=0
    tcp_transform[2]=0
    tcp_transform=pose_inv(tcp_transform)
    local tcpF=pose_trans(tcp_transform,p[sFT[0],sFT[1],sFT[2],0,0,0])
    local tcpT=pose_trans(tcp_transform,p[sFT[3],sFT[4],sFT[5],0,0,0])
    Fx=tcpF[0]
    Fy=tcpF[1]
    Fz=tcpF[2]
    Tx=tcpT[0]
    Ty=tcpT[1]
    Tz=tcpT[2]
    F3D=sqrt(Fx*Fx+Fy*Fy+Fz*Fz)
    T3D=sqrt(Tx*Tx+Ty*Ty+Tz*Tz)
    local act_transform=get_actual_tool_flange_pose()
    act_transform[0]=0
    act_transform[1]=0
    act_transform[2]=0
    local bF=pose_trans(act_transform,p[sFT[0],sFT[1],sFT[2],0,0,0])
    local bT=pose_trans(act_transform,p[sFT[3],sFT[4],sFT[5],0,0,0])
    bFT=[bF[0],bF[1],bF[2],bT[0],bT[1],bT[2]]
    tFT=[Fx,Fy,Fz,Tx,Ty,Tz]
    of_appvect[6]=of_v2r_received
    end
    if OF_DEBUG_STATE:
    textmsg("Stopping vectorProcess thread")
    end
    end
    def get_of_appvect():
    return[of_appvect[0],of_appvect[1],of_appvect[2],of_appvect[3],of_appvect[4],of_appvect[5]]
    end
    def get_of_appvect_pose():
    return p[of_appvect[0],of_appvect[1],of_appvect[2],of_appvect[3],of_appvect[4],of_appvect[5]]
    end
    thread of_safeguard_thread():
    if OF_DEBUG_STATE:
    textmsg("SafeGuard thread starting..")
    end
    of_wait_ms(300)
    of_sg_count=of_v2r_received
    while of_portopened_vectorStream:
    sync()
    of_sg_count=of_sg_count+1
    of_compute_engine_ping=of_sg_count-of_v2r_received
    if of_compute_engine_ping>OF_APP_ENGINE_PING_LIMIT:
    textmsg(of_ce_comm_safeguard_lost_error)
    popup(of_ce_comm_safeguard_lost_error,title=of_ce_comm_error_title,error=True,blocking=False)
    halt
    end
    if of_compute_engine_ping>of_compute_engine_ping_max:
    of_compute_engine_ping_max=of_compute_engine_ping
    end
    of_sg_count=of_sg_count-0.05*of_compute_engine_ping
    end
    if OF_DEBUG_STATE:
    textmsg("SafeGuard thread stopped")
    end
    end
    def of_portclose_commandFlow():
    socket_close("commandFlow")
    of_portopened_commandFlow=False
    end
    def of_portopen_commandFlow():
    of_portclose_commandFlow()
    of_portopened_commandFlow=socket_open(of_compute_engine_IP,OF_COMMAND_PORT,"commandFlow")
    if not of_portopened_commandFlow:
    popup(of_ce_comm_commandflow_open_error,title=of_ce_comm_error_title,error=True,blocking=False)
    halt
    end
    end
    thread of_commandFlow_thread():
    if OF_DEBUG_STATE:
    textmsg("Starting commandFlow thread..")
    end
    while of_portopened_commandFlow:
    of_cmd_rx=socket_read_binary_integer(2,"commandFlow")
    if of_cmd_rx[0]!=0:
    parse_command()
    end
    sync()
    of_cmd_received=of_cmd_received+1
    end
    if OF_DEBUG_STATE:
    textmsg("Stopping commandFlow thread")
    end
    end
    def of_send_command(command):
    sync()
    if OF_DEBUG_CMD or OF_DEBUG_TX:
    textmsg("Sending command: ",command)
    end
    succ=socket_send_int(command,"commandFlow")
    if not succ:
    if OF_DEBUG_STATE and OF_DEBUG_TX:
    textmsg(of_ce_comm_cmd_send_error,command)
    popup(of_ce_comm_cmd_send_again,title=of_ce_comm_error_title,error=True,blocking=False)
    end
    sync()
    of_send_command(command)
    end
    end
    def of_send_int(intvalue):
    if OF_DEBUG_TX:
    textmsg("Sending integer: ",intvalue)
    end
    local succ=socket_send_int(intvalue,"commandFlow")
    if not succ:
    if OF_DEBUG_STATE and OF_DEBUG_TX:
    textmsg(of_ce_comm_int_send_error,intvalue)
    popup(of_ce_comm_int_send_again,title=of_ce_comm_error_title,error=True,blocking=False)
    end
    sync()
    of_send_int(intvalue)
    end
    end
    def of_send_float_as_int(floatvalue):
    local value=of_float_to_int(floatvalue)
    if OF_DEBUG_TX:
    textmsg("Sending [float, as int]: ",[floatvalue,value])
    end
    local succ=socket_send_int(value,"commandFlow")
    if not succ:
    if OF_DEBUG_STATE and OF_DEBUG_TX:
    textmsg(of_ce_comm_float_send_error,floatvalue)
    popup(of_ce_comm_float_send_again,title=of_ce_comm_error_title,error=True,blocking=False)
    end
    sync()
    of_send_float_as_int(floatvalue)
    end
    end
    def of_send_dummies(count):
    if OF_DEBUG_TX:
    textmsg("Sending dummies: ",count)
    end
    local counter=0
    while counter<count:
    local succ=socket_send_int(OF_DUMMY_VALUE,"commandFlow")
    if not succ:
    if OF_DEBUG_STATE and OF_DEBUG_TX:
    textmsg(of_ce_comm_dummy_send_error,[(counter+1),count])
    popup(of_ce_comm_dummy_send_again,title=of_ce_comm_error_title,error=True,blocking=False)
    end
    counter=counter-1
    sync()
    end
    counter=counter+1
    end
    end
    thread of_speedl_thread():
    if OF_DEBUG_STATE:
    textmsg("Speedl stream started..")
    end
    enter_critical
    of_speedl_is_running=True
    exit_critical
    speedbase=[0,0,0,0,0,0]
    if of_speedl_for_handguide:
    while of_speedl_is_running:
    speedbase=get_of_appvect()
    if of_hg_caranteen_reached:
    if of_hg_caranteen_safemode:
    local XYplane=get_actual_tool_flange_pose()
    if(XYplane[0]<0 and speedbase[0]>0)or(XYplane[0]>0 and speedbase[0]<0):
    speedbase[0]=0
    end
    if(XYplane[1]<0 and speedbase[1]>0)or(XYplane[1]>0 and speedbase[1]<0):
    speedbase[1]=0
    end
    else:
    speedbase=[0,0,0,0,0,0]
    end
    end
    speedl(speedbase,a=of_speedl_acc,t=0.001)
    end
    else:
    while of_speedl_is_running:
    speedbase=get_of_appvect()
    speedl(speedbase,a=of_speedl_acc,t=0.001)
    end
    end
    if OF_DEBUG_STATE:
    textmsg("Speedl stream ended.")
    end
    end
    def of_speedl_stop_for(stopLimit=False,stopFTControl=False,stopMove=False,stopHandGuide=False):
    if(not stopLimit)and(not stopFTControl)and(not stopMove)and(not stopHandGuide):
    textmsg("No speedl command has been stopped")
    end
    if stopLimit:
    of_speedl_for_limit=False
    end
    if stopFTControl:
    of_speedl_for_ftcontrol=False
    end
    if stopMove:
    of_speedl_for_move=False
    end
    if stopHandGuide:
    of_speedl_for_handguide=False
    end
    if not(of_speedl_for_limit or of_speedl_for_ftcontrol or of_speedl_for_move or of_speedl_for_handguide):
    kill of_speedl_thread_handler
    enter_critical
    of_speedl_is_running=False
    exit_critical
    if OF_DEBUG_STATE:
    textmsg("Speedl stream stopped")
    end
    stopl(10)
    end
    return of_speedl_is_running
    end
    def of_hg_stop_limit_reached():
    local is_reached=False
    if(of_hg_enable_axes[0]and(Fx>of_hg_stop_F)):
    is_reached=True
    elif(of_hg_enable_axes[1]and(Fy>of_hg_stop_F)):
    is_reached=True
    elif(of_hg_enable_axes[2]and(Fz>of_hg_stop_F)):
    is_reached=True
    elif(of_hg_enable_axes[3]and(Tx>of_hg_stop_T)):
    is_reached=True
    elif(of_hg_enable_axes[4]and(Ty>of_hg_stop_T)):
    is_reached=True
    elif(of_hg_enable_axes[5]and(Tz>of_hg_stop_T)):
    is_reached=True
    end
    return is_reached
    end
    def of_hg_stop_area_reached():
    local is_reached=False
    local Zzero=p[0,0,0,0,0,0]
    local XYplane=p[0,0,0,0,0,0]
    local act_flange=get_actual_tool_flange_pose()
    local act_joints=get_actual_joint_positions()
    XYplane[0]=act_flange[0]
    XYplane[1]=act_flange[1]
    local qWrist2=act_joints[4]%MATH_PI
    local dist2Z=point_dist(XYplane,Zzero)
    local dist2Z_min=of_hg_axisZ_dist+(of_hg_TMB_dist*cos(act_joints[4]))
    if(dist2Z<dist2Z_min):
    of_hg_caranteen_reached=True
    elif(dist2Z>dist2Z_min+0.01):
    of_hg_caranteen_reached=False
    if of_hg_caranteen_safemode:
    of_hg_caranteen_safemode=False
    textmsg(of_hand_guide_safemode_exit)
    end
    end
    if(norm(qWrist2)<of_hg_joints_min_dev):
    is_reached=True
    end
    return is_reached
    end
    def of_wait_for_ACK(timeout=0):
    local timeout_sync_max=timeout*125
    local timeout_sync=0
    local timedOut=False
    if timeout>=0:
    useTimeout=True
    else:
    useTimeout=False
    end
    syncCounter=0
    enter_critical
    local ackReceived=of_ack_received
    exit_critical
    while((not ackReceived)and(not timedOut)):
    sync()
    if useTimeout:
    timeout_sync=timeout_sync+1
    if timeout_sync>timeout_sync_max:
    timedOut=True
    end
    end
    enter_critical
    ackReceived=of_ack_received
    exit_critical
    end
    enter_critical
    of_ack_received=False
    exit_critical
    end
    def of_ack_send():
    if OF_DEBUG_STATE:
    textmsg("Acknowledge sending started..")
    end
    of_send_command(OF_CMD_ACK)
    of_send_dummies(OF_CMD_TX_PARAM_LENGTH-0)
    of_wait_for_ACK()
    if OF_DEBUG_STATE:
    textmsg("Acknowledge sent")
    end
    end
    def of_stop_atomic(stopLimit=False,stopFTControl=False,stopMove=False,stopHandGuide=False):
    if(not stopLimit)and(not stopFTControl)and(not stopMove):
    textmsg("No atomic command has been stopped")
    end
    local stopFTControlOrHandGuide=stopFTControl or stopHandGuide
    if OF_DEBUG_STATE:
    textmsg("Stop Atomic sending.. ",[stopLimit,stopFTControl,stopMove,stopHandGuide])
    end
    if stopFTControl:
    of_ft_control_state=OF_FT_CONTROL_STATE_IDLE
    of_move_parent_frameID=0
    of_move_parent_frame=ZEROFRAME
    end
    if stopHandGuide:
    of_ft_control_state=OF_FT_CONTROL_STATE_IDLE
    of_move_parent_frameID=0
    of_move_parent_frame=ZEROFRAME
    end
    of_cmd_stop_arg=binary_list_to_integer([stopLimit,stopFTControlOrHandGuide,stopMove])
    of_send_command(OF_CMD_STOP)
    of_send_int(of_cmd_stop_arg)
    of_send_dummies(OF_CMD_TX_PARAM_LENGTH-1)
    of_wait_for_ACK()
    of_speedl_stop_for(stopLimit,stopFTControl,stopMove,stopHandGuide)
    if OF_DEBUG_STATE:
    textmsg("Stop Atomic sent: ",of_cmd_stop_arg)
    end
    return of_speedl_is_running
    end
    def of_start_atomic(startLimit=False,startFTControl=False,startMove=False,startHandGuide=False):
    if(not startLimit)and(not startFTControl)and(not startMove)and(not startHandGuide):
    textmsg("No atomic command has been started")
    end
    if startLimit:
    if OF_DEBUG_STATE:
    textmsg("Start Atomic (Limit) sending..")
    end
    of_send_command(OF_CMD_START)
    of_send_int(OF_CMD_LIMIT)
    of_send_dummies(OF_CMD_TX_PARAM_LENGTH-1)
    of_wait_for_ACK()
    of_speedl_for_limit=True
    if OF_DEBUG_STATE:
    textmsg("Start Atomic (Limit) sent")
    end
    end
    if startFTControl:
    if OF_DEBUG_STATE:
    textmsg("Start Atomic (FTControl) sending..")
    end
    of_send_command(OF_CMD_START)
    of_send_int(OF_CMD_FT_CONTROL)
    of_send_dummies(OF_CMD_TX_PARAM_LENGTH-1)
    of_wait_for_ACK()
    of_speedl_for_ftcontrol=True
    if OF_DEBUG_STATE:
    textmsg("Start Atomic (FTControl) sent")
    end
    end
    if startMove:
    if OF_DEBUG_STATE:
    textmsg("Start Atomic (Move) sending..")
    end
    of_send_command(OF_CMD_START)
    of_send_int(OF_CMD_MOVE)
    of_send_dummies(OF_CMD_TX_PARAM_LENGTH-1)
    of_wait_for_ACK()
    of_speedl_for_move=True
    if OF_DEBUG_STATE:
    textmsg("Start Atomic (Move) sent")
    end
    end
    if startHandGuide:
    if OF_DEBUG_STATE:
    textmsg("Start Atomic (FTControl) sending..")
    end
    of_send_command(OF_CMD_START)
    of_send_int(OF_CMD_FT_CONTROL)
    of_send_dummies(OF_CMD_TX_PARAM_LENGTH-1)
    of_wait_for_ACK()
    of_speedl_for_handguide=True
    if OF_DEBUG_STATE:
    textmsg("Start Atomic (HandGuide) sent")
    end
    end
    if(of_speedl_for_limit or of_speedl_for_ftcontrol or of_speedl_for_move or of_speedl_for_handguide):
    if not of_speedl_is_running:
    of_speedl_thread_handler=run of_speedl_thread()
    end
    end
    return of_speedl_is_running
    end
    def of_ft_bias():
    if OF_DEBUG_STATE:
    textmsg("FT Bias sending...")
    end
    of_send_command(OF_CMD_BIAS)
    of_send_int(0)
    of_send_dummies(OF_CMD_TX_PARAM_LENGTH-1)
    of_wait_for_ACK()
    if OF_DEBUG_STATE:
    textmsg("FT Bias sent.")
    end
    end
    def of_tcp_offset_send():
    if OF_DEBUG_STATE:
    textmsg("TCP Offset sending started!")
    end
    of_TCP_offset=of_tcp_offset_calc()
    of_send_command(OF_CMD_TCP)
    of_send_float_as_int(of_TCP_offset[0])
    of_send_float_as_int(of_TCP_offset[1])
    of_send_float_as_int(of_TCP_offset[2])
    of_send_float_as_int(of_TCP_offset[3])
    of_send_float_as_int(of_TCP_offset[4])
    of_send_float_as_int(of_TCP_offset[5])
    of_send_dummies(OF_CMD_TX_PARAM_LENGTH-6)
    of_wait_for_ACK()
    if OF_DEBUG_STATE:
    textmsg("TCP Offset sent.")
    end
    end
    def of_sensor_config_send(sensorFlangeOffset=ZEROFRAME,sensorTCPOffset=ZEROFRAME):
    if OF_DEBUG_STATE:
    textmsg("Sensor Config sending started!")
    end
    of_send_command(OF_CMD_TCP)
    of_send_float_as_int(sensorFlangeOffset[0])
    of_send_float_as_int(sensorFlangeOffset[1])
    of_send_float_as_int(sensorFlangeOffset[2])
    of_send_float_as_int(sensorFlangeOffset[3])
    of_send_float_as_int(sensorFlangeOffset[4])
    of_send_float_as_int(sensorFlangeOffset[5])
    of_send_float_as_int(sensorTCPOffset[0])
    of_send_float_as_int(sensorTCPOffset[1])
    of_send_float_as_int(sensorTCPOffset[2])
    of_send_float_as_int(sensorTCPOffset[3])
    of_send_float_as_int(sensorTCPOffset[4])
    of_send_float_as_int(sensorTCPOffset[5])
    of_send_dummies(OF_CMD_TX_PARAM_LENGTH-12)
    of_wait_for_ACK()
    if OF_DEBUG_STATE:
    textmsg("Sensor Config sent.")
    end
    end
    def of_cog_send(robot_mount=[0,0],center_of_gravity=[0,0,0],payload=0):
    if OF_DEBUG_STATE:
    textmsg("Robot mount, Center of Gravity & Payload sending started!")
    end
    of_send_command(OF_CMD_TCP)
    of_send_float_as_int(robot_mount[0])
    of_send_float_as_int(robot_mount[1])
    of_send_float_as_int(center_of_gravity[0])
    of_send_float_as_int(center_of_gravity[1])
    of_send_float_as_int(center_of_gravity[2])
    of_send_float_as_int(payload)
    of_send_dummies(OF_CMD_TX_PARAM_LENGTH-6)
    of_wait_for_ACK()
    if OF_DEBUG_STATE:
    textmsg("Robot mount, Center of Gravity & Payload sent.")
    end
    end
    def of_limit_start(ft_select=FALSE8D,ft_limits=[0,0,0,0,0,0,0,0],ft_abs=FALSE6D,timeout=0,v_min=0,frameID=0,frameRPY=[0,0,0],forFTControl=False,popupmsg=True):
    local binary_list=integer_to_binary_list(0)
    local iBin=0
    while iBin<15:
    if iBin<6:
    binary_list[iBin]=ft_abs[iBin]
    elif iBin<(6+8):
    binary_list[iBin]=ft_select[iBin-6]
    elif iBin==14:
    binary_list[iBin]=forFTControl
    else:
    sync()
    end
    iBin=iBin+1
    end
    local int_bool_list=binary_list_to_integer(binary_list)
    local frame_rotvec=rpy2rotvec(frameRPY)
    of_send_command(OF_CMD_LIMIT)
    of_send_float_as_int(ft_limits[0])
    of_send_float_as_int(ft_limits[1])
    of_send_float_as_int(ft_limits[2])
    of_send_float_as_int(ft_limits[3])
    of_send_float_as_int(ft_limits[4])
    of_send_float_as_int(ft_limits[5])
    of_send_float_as_int(ft_limits[6])
    of_send_float_as_int(ft_limits[7])
    of_send_int(int_bool_list)
    of_send_float_as_int(timeout)
    of_send_float_as_int(v_min)
    of_send_int(frameID)
    of_send_float_as_int(frame_rotvec[0])
    of_send_float_as_int(frame_rotvec[1])
    of_send_float_as_int(frame_rotvec[2])
    of_send_dummies(OF_CMD_TX_PARAM_LENGTH-15)
    of_wait_for_ACK()
    end
    def of_limit_stop(forFTControl=False):
    of_stop_atomic(stopLimit=True)
    end
    def of_ft_control_start(ft_select=FALSE6D,ft_values=[0.0,0.0,0.0,0.0,0.0,0.0],frameID=0,frameRPY=[0,0,0],forcePID=[1.0,0.0,0.0],torquePID=[1.0,0.0,0.0],deviation_max=0):
    if not(of_ft_control_state==OF_FT_CONTROL_STATE_IDLE):
    popup(of_ft_control_start_error,title=of_cmd_error_title,error=True,blocking=False)
    of_ft_control_state=of_ft_control_state+1
    else:
    of_ft_control_state=OF_FT_CONTROL_STATE_RUNNING
    end
    of_tcp_offset_send()
    local flags=binary_list_to_integer(ft_select)+(frameID*64)
    local frame_rotvec=rpy2rotvec(frameRPY)
    if OF_DEBUG_STATE:
    textmsg("Start force mode")
    end
    of_send_command(OF_CMD_FT_CONTROL)
    of_send_float_as_int(ft_values[0])
    of_send_float_as_int(ft_values[1])
    of_send_float_as_int(ft_values[2])
    of_send_float_as_int(ft_values[3])
    of_send_float_as_int(ft_values[4])
    of_send_float_as_int(ft_values[5])
    of_send_int(flags)
    of_send_float_as_int(frame_rotvec[0])
    of_send_float_as_int(frame_rotvec[1])
    of_send_float_as_int(frame_rotvec[2])
    of_send_float_as_int(forcePID[0])
    of_send_float_as_int(forcePID[1])
    of_send_float_as_int(forcePID[2])
    of_send_float_as_int(torquePID[0])
    of_send_float_as_int(torquePID[1])
    of_send_float_as_int(torquePID[2])
    of_send_float_as_int(deviation_max)
    of_send_dummies(OF_CMD_TX_PARAM_LENGTH-17)
    of_wait_for_ACK()
    of_speedl_for_ftcontrol=True
    if not of_speedl_is_running:
    of_speedl_thread_handler=run of_speedl_thread()
    end
    if frameID==0 or frameID==1 or frameID==2 or frameID==3:
    of_move_parent_frameID=frameID
    of_move_parent_frame=p[0,0,0,frame_rotvec[0],frame_rotvec[1],frame_rotvec[2]]
    else:
    of_move_parent_frameID=0
    of_move_parent_frame=ZEROFRAME
    end
    if OF_DEBUG_STATE:
    textmsg("FT Control started")
    end
    end
    def of_ft_control_stop():
    of_stop_atomic(stopFTControl=True)
    of_ft_control_state=OF_FT_CONTROL_STATE_IDLE
    of_move_parent_frameID=0
    of_move_parent_frame=ZEROFRAME
    end
    def of_hand_guide_start(axes_en=FALSE6D,thresholdF=15,thresholdT=0.6,saturationV=0.6,saturationW=0.2,stopF=100,stopT=5,gainF=1,gainT=1):
    if OF_DEBUG_STATE:
    textmsg("Starting hand guide")
    end
    of_tcp_offset_send()
    local Axes_en=binary_list_to_integer(axes_en)
    if OF_DEBUG_VAR:
    textmsg("Axes_en: ",Axes_en)
    end
    of_hg_stop_F=stopF
    of_hg_stop_T=stopT
    of_send_command(OF_CMD_HAND_GUIDE)
    of_send_int(Axes_en)
    of_send_float_as_int(thresholdF)
    of_send_float_as_int(thresholdT)
    of_send_float_as_int(saturationV)
    of_send_float_as_int(saturationW)
    of_send_float_as_int(stopF)
    of_send_float_as_int(stopT)
    of_send_float_as_int(gainF)
    of_send_float_as_int(gainT)
    of_send_dummies(OF_CMD_TX_PARAM_LENGTH-9)
    of_wait_for_ACK()
    of_speedl_for_handguide=True
    if not of_speedl_is_running:
    of_speedl_thread_handler=run of_speedl_thread()
    end
    if OF_DEBUG_STATE:
    textmsg("HandGuide started")
    end
    end
    def of_hand_guide_stop():
    of_stop_atomic(stopHandGuide=True)
    end
    def of_move_init(frameID=0,frameRPY=[0,0,0],speed=0.05,acc=1.2,scale=False,move2First=True,move21Last=True):
    sync()
    if not(of_move_state==OF_MOVE_STATE_IDLE):
    textmsg("of_move_state: ",of_move_state)
    popup(of_move_init_error,title=of_move_error_title,error=True,blocking=False)
    halt
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_INIT
    exit_critical
    if OF_DEBUG_STATE:
    textmsg("FT Move initializing..")
    end
    if not(speed>0):
    popup(of_move_parameter_error_speed,title=of_move_error_title,error=True,blocking=False)
    halt
    elif not(acc>0):
    popup(of_move_parameter_error_acc,title=of_move_error_title,error=True,blocking=False)
    halt
    else:
    sync()
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_GLOBALS_SET
    exit_critical
    of_tcp_offset_send()
    of_move_frameID=frameID
    if frameID==0 or frameID==1:
    of_move_frame=ZEROFRAME
    elif frameID==2 or frameID==3:
    frame_rotvec=rpy2rotvec(frameRPY)
    of_move_frame=p[0,0,0,frame_rotvec[0],frame_rotvec[1],frame_rotvec[2]]
    elif frameID==4:
    parentID=of_move_parent_frameID
    if parentID==0 or parentID==1 or parentID==2 or parentID==3:
    of_move_frameID=of_move_parent_frameID
    of_move_frame=of_move_parent_frame
    else:
    textmsg("Invalid of_move_parent_frameID, frame set to Base. Invalid ID: ",of_move_parent_frameID)
    of_move_parent_frameID=0
    of_move_parent_frame=ZEROFRAME
    of_move_frameID=of_move_parent_frameID
    of_move_frame=of_move_parent_frame
    end
    sync()
    else:
    popup(of_move_parameter_error_coordsys,title=of_move_error_title,error=True,blocking=False)
    halt
    end
    of_move_path_move_home=False
    of_move_path_count=0
    of_move_wp_count=0
    of_move_last_pose=get_actual_tcp_pose()
    local flags=binary_list_to_integer([scale,move2First,move21Last])
    enter_critical
    of_move_state=OF_MOVE_STATE_PARAM_SEND
    exit_critical
    of_send_command(OF_CMD_MOVE)
    of_send_float_as_int(speed)
    of_send_float_as_int(acc)
    of_send_int(of_move_frameID)
    of_send_float_as_int(of_move_frame[3])
    of_send_float_as_int(of_move_frame[4])
    of_send_float_as_int(of_move_frame[5])
    of_send_int(flags)
    of_send_dummies(OF_CMD_TX_PARAM_LENGTH-7)
    enter_critical
    of_move_state=OF_MOVE_STATE_PARAM_SENT
    exit_critical
    of_wait_for_ACK()
    if OF_DEBUG_STATE:
    textmsg("FT Move initialized")
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_INITED
    exit_critical
    sync()
    end
    def of_move_send_start():
    of_start_atomic(startMove=True)
    end
    def of_move_start_move(popupmsg=True):
    sync()
    if(of_move_state==OF_MOVE_STATE_PATH_STOPPED):
    sync()
    elif not(of_move_state==OF_MOVE_STATE_INITED):
    textmsg("of_move_state: ",of_move_state)
    popup(of_move_start_error,title=of_move_error_title,error=True,blocking=False)
    halt
    else:
    enter_critical
    of_move_state=OF_MOVE_STATE_STARTING
    exit_critical
    if not(of_move_wp_count>0 or of_move_path_count==1):
    textmsg("[Waypoint#, Path#]: ",[of_move_wp_count,of_move_path_count])
    popup(of_move_parameter_error_count,title=of_move_error_title,error=True,blocking=False)
    halt
    else:
    sync()
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_WP_SENT
    exit_critical
    of_move_send_start()
    if OF_DEBUG_STATE:
    textmsg("FT Move started")
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_STARTED
    exit_critical
    while of_move_state==OF_MOVE_STATE_STARTED:
    sync()
    end
    of_speedl_stop_for(stopMove=True)
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_FINISHED
    exit_critical
    if OF_DEBUG_STATE:
    textmsg("FT Move finished with return value: ",of_move_return)
    end
    if of_move_return==0:
    elif of_move_return==1:
    if popupmsg:
    popup(of_move_move_return_1,title=of_move_move_return_title,error=True,blocking=True)
    end
    elif of_move_return==3:
    if popupmsg:
    popup(of_move_move_return_3,title=of_move_move_return_title,error=True,blocking=True)
    end
    elif of_move_return==11:
    popup(of_move_move_return_11,title=of_move_move_return_title,error=True,blocking=True)
    elif of_move_return==12:
    popup(of_move_move_return_12,title=of_move_move_return_title,error=True,blocking=True)
    elif of_move_return==13:
    popup(of_move_move_return_13,title=of_move_move_return_title,error=True,blocking=True)
    elif of_move_return==14:
    popup(of_move_move_return_14,title=of_move_move_return_title,error=True,blocking=True)
    else:
    popup(of_move_move_return_unknown,title=of_move_move_return_title,error=True,blocking=False)
    end
    if(of_move_path_move_home):
    if(of_move_return==0):
    enter_critical
    of_move_state=OF_MOVE_STATE_INITED
    exit_critical
    else:
    enter_critical
    of_move_state=OF_MOVE_STATE_PATH_STOPPED
    exit_critical
    end
    else:
    enter_critical
    of_move_state=OF_MOVE_STATE_IDLE
    exit_critical
    end
    sync()
    return of_move_return
    end
    def of_move_start_search(popupmsg=True):
    sync()
    if(of_move_state==OF_MOVE_STATE_PATH_STOPPED):
    sync()
    elif not(of_move_state==OF_MOVE_STATE_INITED):
    textmsg("of_move_state: ",of_move_state)
    popup(of_move_start_error,title=of_search_error_title,error=True,blocking=False)
    halt
    else:
    enter_critical
    of_move_state=OF_MOVE_STATE_STARTING
    exit_critical
    if not(of_move_wp_count>0 or of_move_path_count==1):
    textmsg("[Waypoint#, Path#]: ",[of_move_wp_count,of_move_path_count])
    popup(of_move_parameter_error_count,title=of_search_error_title,error=True,blocking=False)
    halt
    else:
    sync()
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_WP_SENT
    exit_critical
    of_move_send_start()
    if OF_DEBUG_STATE:
    textmsg("FT Move started")
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_STARTED
    exit_critical
    while of_move_state==OF_MOVE_STATE_STARTED:
    sync()
    end
    of_speedl_stop_for(stopMove=True)
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_FINISHED
    exit_critical
    local of_search_return=of_move_return
    if of_move_return==0:
    of_search_return=1
    elif of_move_return==1:
    of_search_return=0
    end
    if OF_DEBUG_STATE:
    textmsg("FT Search finished with return value: ",of_search_return)
    end
    if of_search_return==0:
    elif of_search_return==1:
    if popupmsg:
    popup(of_move_search_return_1,title=of_move_search_return_title,error=True,blocking=True)
    end
    elif of_search_return==3:
    if popupmsg:
    popup(of_move_search_return_3,title=of_move_search_return_title,error=True,blocking=True)
    end
    elif of_search_return==11:
    popup(of_move_search_return_11,title=of_move_search_return_title,error=True,blocking=True)
    elif of_search_return==12:
    popup(of_move_search_return_12,title=of_move_search_return_title,error=True,blocking=True)
    elif of_search_return==13:
    popup(of_move_search_return_13,title=of_move_search_return_title,error=True,blocking=True)
    elif of_search_return==14:
    popup(of_move_search_return_14,title=of_move_search_return_title,error=True,blocking=True)
    else:
    popup(of_move_search_return_unknown,title=of_move_search_return_title,error=True,blocking=True)
    end
    if(of_move_path_move_home):
    if(of_move_return==0):
    enter_critical
    of_move_state=OF_MOVE_STATE_INITED
    exit_critical
    else:
    enter_critical
    of_move_state=OF_MOVE_STATE_PATH_STOPPED
    exit_critical
    end
    else:
    enter_critical
    of_move_state=OF_MOVE_STATE_IDLE
    exit_critical
    end
    sync()
    return of_search_return
    end
    def of_move_limit_return(limit_return):
    if limit_return==0:
    of_move_return=0
    elif limit_return==1:
    of_move_return=1
    else:
    of_move_return=2
    if OF_DEBUG_STATE:
    textmsg("FT Move returned with limit_return: ",limit_return)
    end
    end
    end
    def of_move_stop():
    if of_move_state==OF_MOVE_STATE_IDLE:
    textmsg("No move command has been stopped")
    else:
    enter_critical
    of_move_state=OF_MOVE_STATE_STOPPING
    exit_critical
    of_stop_atomic(stopMove=True)
    end
    while of_move_state==OF_MOVE_STATE_STOPPING:
    sync()
    end
    enter_critical
    of_move_state=OF_MOVE_STATE_IDLE
    exit_critical
    end
    def of_waypoint_send(wp):
    if not(wp==ZEROPOSE):
    relativeWPInt=0
    of_send_command(OF_CMD_WAYPOINT)
    of_send_float_as_int(wp[0])
    of_send_float_as_int(wp[1])
    of_send_float_as_int(wp[2])
    of_send_float_as_int(wp[3])
    of_send_float_as_int(wp[4])
    of_send_float_as_int(wp[5])
    of_send_int(relativeWPInt)
    of_send_dummies(OF_CMD_TX_PARAM_LENGTH-7)
    of_wait_for_ACK()
    if OF_DEBUG_STATE:
    textmsg("FT Waypoint sent: ",wp)
    end
    of_move_wp_count=of_move_wp_count+1
    else:
    textmsg("Invalid FT Waypoint and not sent")
    end
    end
    def of_waypoint(fixP=ZEROPOSE,variableP=p[0,0,0,0,0,0],relativeP=p[0,0,0,0,0,0]):
    sync()
    local mergedWP=ZEROPOSE
    local startPose=ZEROPOSE
    local frameID=of_move_frameID
    if not(of_move_state==OF_MOVE_STATE_INITED):
    textmsg("of_move_state: ",of_move_state)
    popup(of_waypoint_move_state_error,title=of_waypoint_error_title,error=True,blocking=False)
    halt
    end
    if of_move_path_count!=0:
    popup(of_waypoint_path_count_error,title=of_waypoint_error_title,error=True,blocking=False)
    halt
    end
    if fixP==ZEROPOSE:
    if variableP==ZEROPOSE:
    if(relativeP==ZEROPOSE):
    popup(of_waypoint_parameter_error_target,title=of_waypoint_error_title,error=True,blocking=False)
    halt
    end
    if frameID==0:
    startPose=of_move_last_pose
    elif frameID==1:
    startPose=ZEROPOSE
    elif frameID==2:
    startPose=pose_trans(pose_inv(of_move_frame),of_move_last_pose)
    elif frameID==3:
    startPose=pose_inv(of_move_frame)
    else:
    startPose=of_move_last_pose
    end
    else:
    startPose=variableP
    end
    mergedCustom=pose_add(relativeP,startPose)
    if frameID==0:
    mergedWP=mergedCustom
    elif frameID==1:
    mergedWP= pose_trans(of_move_last_pose,mergedCustom)
    elif frameID==2:
    mergedWP=pose_trans(of_move_frame,mergedCustom)
    elif frameID==3:
    local customMerged=pose_trans(of_move_frame,mergedCustom)
    mergedWP=pose_trans(of_move_last_pose,customMerged)
    end
    else:
    mergedWP=fixP
    end
    local poseDiff=point_dist(mergedWP,of_move_last_pose)
    if((of_move_wp_count!=0)and(poseDiff<of_move_min_dist)):
    textmsg("Distance to the last pose: ",poseDiff)
    popup(of_waypoint_parameter_error_close,title=of_waypoint_error_title,error=True,blocking=False)
    halt
    else:
    of_waypoint_send(mergedWP)
    end
    of_move_last_pose=mergedWP
    return mergedWP
    end
    def of_path(pathID):
    sync()
    if not(of_move_state==OF_MOVE_STATE_INITED or of_move_state==OF_MOVE_STATE_PATH_STOPPED):
    textmsg("of_move_state: ",of_move_state)
    popup(of_path_move_state_error,title=of_path_error_title,error=True,blocking=False)
    halt
    end
    if not(of_move_path_count==0):
    popup(of_path_path_count_error,title=of_path_error_title,error=True,blocking=False)
    halt
    end
    if not((of_move_wp_count==0 and not of_move_path_move_home)or(of_move_wp_count==1 or of_move_path_move_home)):
    textmsg("Path home & Waypoint#: ",[binary_list_to_integer([of_move_path_move_home]),of_move_wp_count])
    popup(of_path_wp_count_error,title=of_path_error_title,error=True,blocking=False)
    halt
    end
    if not(pathID>0 or pathID==-1):
    popup(of_path_parameter_error_pathid,title=of_path_error_title,error=True,blocking=False)
    halt
    end
    of_move_path_move_home=False
    of_send_command(OF_CMD_PATH)
    of_send_int(pathID)
    of_send_dummies(OF_CMD_TX_PARAM_LENGTH-1)
    of_wait_for_ACK()
    of_move_path_count=of_move_path_count+1
    if OF_DEBUG_STATE:
    textmsg("FT Path sent: ",pathID)
    end
    end
    def of_path_play(pathID=0,relative=False,homePose=ZEROPOSE):
    if relative:
    of_move_path_move_home=False
    else:
    of_move_path_move_home=True
    end
    if not relative:
    of_waypoint(fixP=homePose)
    of_move_start_move(popupmsg=False)
    end
    of_path(pathID)
    end
    def parse_command():
    if of_cmd_rx[0]==0:
    if OF_DEBUG_RX:
    textmsg("Nothing received..")
    end
    elif of_cmd_rx[0]==1:
    if OF_DEBUG_RX:
    textmsg("Half command received: ",of_cmd_rx[1])
    end
    elif of_cmd_rx[0]==2:
    if of_cmd_rx[1]==OF_CMD_ACK:
    enter_critical
    of_ack_received=True
    exit_critical
    if OF_DEBUG_RX:
    textmsg("Acknowledge received")
    end
    elif of_cmd_rx[1]==OF_CMD_STOP:
    brake=of_int_to_float(of_cmd_rx[2])
    stopl(brake)
    if OF_DEBUG_RX:
    textmsg("Stop received: ",brake)
    end
    elif of_cmd_rx[1]==OF_CMD_START:
    if OF_DEBUG_RX:
    textmsg("Start(?) received. NOP ",of_cmd_rx[2])
    end
    elif of_cmd_rx[1]==OF_CMD_BIAS:
    if OF_DEBUG_RX:
    textmsg("FT Bias(?) received. NOP ",of_cmd_rx[2])
    end
    elif of_cmd_rx[1]==OF_CMD_TCP:
    if OF_DEBUG_RX:
    textmsg("TCP(?) received. NOP ",of_cmd_rx[2])
    end
    elif of_cmd_rx[1]==OF_CMD_SENSOR_CONFIG:
    if OF_DEBUG_RX:
    textmsg("Sensor Config(?) received. NOP ",of_cmd_rx[2])
    end
    elif of_cmd_rx[1]==OF_CMD_COG:
    if OF_DEBUG_RX:
    textmsg("COG(?) received. NOP ",of_cmd_rx[2])
    end
    elif of_cmd_rx[1]==OF_CMD_LIMIT:
    of_limit_return=of_cmd_rx[2]
    of_move_limit_return(of_limit_return)
    if OF_DEBUG_RX:
    textmsg("Limit return received: ",of_limit_return)
    end
    elif of_cmd_rx[1]==OF_CMD_FT_CONTROL:
    of_ft_control_return=of_cmd_rx[2]
    if OF_DEBUG_RX:
    textmsg("FT Control return (?) received. NOP ",of_ft_control_return)
    end
    elif of_cmd_rx[1]==OF_CMD_HAND_GUIDE:
    of_handguide_return=of_cmd_rx[2]
    if OF_DEBUG_RX:
    textmsg("HandGuide return (?) received. NOP ",of_handguide_return)
    end
    elif of_cmd_rx[1]==OF_CMD_MOVE:
    of_move_return=of_cmd_rx[2]
    if not(of_move_state==OF_MOVE_STATE_STARTED or of_move_state==OF_MOVE_STATE_PATH_STOPPED or of_move_state==OF_MOVE_STATE_STOPPING):
    textmsg("of_move_state: ",of_move_state)
    popup(of_move_return_error,title=of_move_error_title,error=True,blocking=False)
    halt
    else:
    enter_critical
    of_move_state=OF_MOVE_STATE_RETURNING
    exit_critical
    end
    if OF_DEBUG_RX:
    textmsg("Return FT Move command received: ",of_move_return)
    end
    elif of_cmd_rx[1]==OF_CMD_WAYPOINT:
    of_waypoint_return=of_cmd_rx[2]
    if OF_DEBUG_RX:
    textmsg("FT Waypoint Return (?) command received. NOP ",of_waypoint_return)
    end
    elif of_cmd_rx[1]==OF_CMD_PATH:
    of_path_return=of_cmd_rx[2]
    if OF_DEBUG_RX:
    textmsg("Return FT Path command received: ",of_path_return)
    end
    elif of_cmd_rx[1]==OF_CMD_DIO:
    local receivedList=integer_to_binary_list(of_cmd_rx[2])
    local valueDO=receivedList[31]
    receivedList[31]=False
    local receivedDO=binary_list_to_integer(receivedList)
    if OF_DEBUG_RX:
    textmsg("Return Set DO command received: ",[receivedDO,valueDO])
    end
    set_standard_digital_out(receivedDO,valueDO)
    of_send_command(OF_CMD_ACK)
    textmsg("Digital Output #, set to #: ",[receivedDO,valueDO])
    elif of_cmd_rx[1]==OF_CMD_AIO:
    local receivedInt=of_cmd_rx[2]
    local selector=pow(2,16)
    local receivedAO=receivedInt%selector
    local valueAO=(receivedInt-receivedAO)/selector/selector
    if OF_DEBUG_RX:
    textmsg("Return Set AO command received: ",[receivedAO,valueAO])
    end
    if receivedAO==0 or receivedAO==1:
    set_standard_analog_out(receivedAO,valueAO)
    else:
    textmsg("Invalid Analog Output selected! ",receivedAO)
    end
    of_send_command(OF_CMD_ACK)
    textmsg("Analog Output #, set to #: ",[receivedAO,valueAO])
    else:
    textmsg("Unknown command received: ",of_cmd_rx)
    end
    else:
    textmsg("Unknown command-length received: ",of_cmd_rx)
    end
    end
    def of_portclose_controlSocket():
    socket_close("controlSocket")
    of_portopened_controlSocket=False
    end
    def of_portopen_controlSocket():
    of_portclose_controlSocket()
    of_portopened_controlSocket=socket_open("127.0.0.1",44005,"controlSocket")
    if not of_portopened_controlSocket:
    popup(of_ce_comm_controlsocket_open_error,title=of_ce_comm_error_title,error=True,blocking=False)
    halt
    end
    end
    of_compute_engine_IP=of_sensor_IP
    of_portopen_vectorStream()
    sync()
    of_vectorStream_thrd=run of_vectorStream_thread()
    sync()
    of_vectorProcess_thrd=run of_vectorProcess_thread()
    sync()
    of_portopen_commandFlow()
    sync()
    of_cmd_thrd=run of_commandFlow_thread()
    sync()
    of_tcp_offset_send()
    of_ft_bias()
    sync()
    of_sg_thrd=run of_safeguard_thread()
    sync()
  
    #==============================================#
    #======    End of OptoForce Interface    ======#
    #==============================================#
  
    #==================================================#
    #======    OptoForce Application Messages    ======#
    #==================================================#
  
    of_move_move_return_2="The move cannot start due to a force or torque exceeding the set limit."
    of_move_search_return_2="The search cannot start due to a force or torque exceeding the set limit."
    of_pin_insertion_param_error_title="OptoForce - Insert Pin error"
    of_pin_insertion_param_error_minDistZ="Please define parameter 'minDistZ' as a positive real number in meters!"
    of_pin_insertion_param_error_forceZ="Please define parameter 'forceZ' as a positive number in Newtons!"
    of_pin_insertion_param_error_maxDistZ="Please define parameter 'maxDistZ' as a positive real number in meters!"
    of_pin_insertion_param_error_maxDistZ_minDistZ="Please define the parameters as 'maxDistZ' >= 'minDistZ'!"
    of_pin_insertion_param_error_expSpeed="Please define parameter 'expSpeed' as a positive real number in meters!"
    of_pin_insertion_param_error_deltaForce="Please define parameter 'deltaForce' as a positive number in Newtons!"
    of_pin_insertion_param_error_timeOut="Please define parameter 'timeOut' as a positive number in seconds!"
    of_pin_insertion_param_error_FTLimits="Please define parameter 'FTLimits' as a 6-element array of positive numbers in Newtons & Newton-meters!"
    of_pin_insertion_param_error_PGainF="Please define parameter 'PGainF' as a positive real number!"
    of_pin_insertion_param_error_PGainT="Please define parameter 'PGainT' as a positive real number!"
    of_pin_insertion_exit_title="OptoForce - Insert Pin"
    of_pin_insertion_exit_maxSideFT="The side-force/-torque limit has been reached after the minimal insertion depth."
    of_pin_insertion_exit_maxSideFT="The side-force/-torque limit has been reached after the minimal insertion depth."
    of_pin_insertion_exit_timeOut="The command has timed out after the minimal insertion depth."
    of_pin_insertion_exit_timeOut="The command has timed out after the minimal insertion depth."
    of_pin_insertion_exit_deltaD="The insertion got stuck before the minimal insertion depth."
    of_center_title="OptoForce - FT Center"
    of_center_return_0="Arrived successfully to the center point."
    of_center_return_1="The first boundary search was unsuccessful. Movement reached the distance limit."
    of_center_return_2="The second boundary search was unsuccessful. Movement reached the distance limit."
    of_center_return_3="Could not reach the center point. The tool collided during the movement."
    of_center_return_4="The search has not been started because of the conditions."
    of_center_return_5="The second search has not been started because of the conditions."
    of_center_return_99="Do not define more than one directional parameter."
    of_center_rxry_title="OptoForce - Orientation center"
    of_center_rxry_return_0="The Orientation centerpoint search was successful"
    of_center_rxry_return_1="The Orientation centerpoint search of Rx was unsuccessful!"
    of_center_rxry_return_2="The Orientation centerpoint search of Ry was unsuccessful!"
    of_fix_and_rotate_title="OptoForce - FT Fix & Rotate"
    of_fix_and_rotate_param_error="Parameter error: rotateEndSearch!"
    of_fix_and_rotate_return_0=""
    of_fix_and_rotate_return_21="The rotation was unsuccessful, collision occurred."
    of_fix_and_rotate_return_22="The rotation ended without contact."
    of_box_ins_title="OptoForce - FT Insert Box"
    of_box_ins_return_0="The Box Insertion finished with no error"
    of_box_ins_return_1="The first direction search was unsuccessful. Movement reached the distance limit."
    of_box_ins_return_2="The second direction search was unsuccessful. Movement reached the distance limit."
    of_box_ins_return_3="The tilt back movement was unsuccessful. Collision occurred."
    of_box_ins_return_4="The tilt movement was unsuccessful. Collision occurred."
    of_box_ins_return_5="The box stuck during the insertion state while center pointing of the X axis! Please check the position and orientation."
    of_box_ins_return_6="The box stuck during the insertion state while center pointing of the Y axis! Please check the position and orientation."
    of_box_ins_return_7="The box stuck during the insertion state while center pointing of the Z axis! Please check the position and orientation."
    of_box_ins_return_8="The box cannot be inserted to position, too many collisions occurred. Please check the position and orientation."
    of_stacking_title="OptoForce - FT Stack/Destack"
    of_stacking_param_error_dir="Please define only one direction parameter!"
    of_stacking_param_error_itmax="The 'it_max' parameter cannot be greather than the distance/thickness!"
    of_stacking_param_error_thickness="The 'thickness' parameter cannot be zero when 'it_max' is not zero!"
    of_stacking_return_0="The FT Stack/Destack finished successfully"
    of_stacking_return_1_stack="The iteration counter is over the maximum: the stack is full."
    of_stacking_return_1_destack="The iteration counter is over the maximum: the stack is empty."
    of_stacking_return_2="Stacking/Destacking is unsuccessful. Next item not found."
    of_stacking_return_3="Stacking/Destacking cannot start due to a force or torque exceeding the set limit."
    of_stacking_return_4="The movement to the next element was unsuccessful, a collision occurred."
    of_stacking_return_5="The movement to the starting point was unsuccessful, a collision occurred."
    of_stacking_param_error_thickness="The 'thickness' parameter cannot be zero when 'it_max' is not zero!"
    of_stacking_param_error_dir="Please define only one direction parameter!"
    of_stacking_param_error_itmax="The 'it_max' parameter cannot be greather than the distance/thickness!"
  
    #=========================================================#
    #======    End of OptoForce Application Messages    ======#
    #=========================================================#
  
    #===============================================#
    #======    Start of OptoForce Elements    ======#
    #===============================================#
  
    of_wait_ms(200)
    MATH_PI=3.141593
    bFT=[0,0,0,0,0,0]
    tFT=[0,0,0,0,0,0]
    def of_qu_inv(qu):
    return[qu[0],-qu[1],-qu[2],-qu[3]]
    end
    def of_qu_mult(x,y):
    local qa=x[0]*y[0]-x[1]*y[1]-x[2]*y[2]-x[3]*y[3]
    local qb=x[0]*y[1]+x[1]*y[0]+x[2]*y[3]-x[3]*y[2]
    local qc=x[0]*y[2]-x[1]*y[3]+x[2]*y[0]+x[3]*y[1]
    local qd=x[0]*y[3]+x[1]*y[2]-x[2]*y[1]+x[3]*y[0]
    local retVal=[qa,qb,qc,qd]
    return retVal
    end
    def of_rotvec2qu(rv):
    local rvlen=sqrt(rv[0]*rv[0]+rv[1]*rv[1]+rv[2]*rv[2])
    if rvlen!=0:
    local rv4=[rvlen,rv[0]/rvlen,rv[1]/rvlen,rv[2]/rvlen]
    else:
    local rv4=[0,0,0,0]
    end
    local rvs=sin(rv4[0]/2)
    return[cos(rv4[0]/2),rvs*rv4[1],rvs*rv4[2],rvs*rv4[3]]
    end
    def of_rotate_qu(v,q):
    local v4=[0,v[0],v[1],v[2]]
    local r4a=of_qu_mult(q,v4)
    local r4b=of_qu_inv(q)
    local r4=of_qu_mult(r4a,r4b)
    return[r4[1],r4[2],r4[3]]
    end
    def of_pose_add(tt,ss,base=True):
    if base:
    local rr=pose_add(ss,tt)
    else:
    local rr=pose_trans(tt,ss)
    end
    return rr
    end
    def of_threshold(fx=0,fy=0,fz=0,tx=0,ty=0,tz=0,f3d=0,t3d=0,force_abs=True,base=True):
    local is_above_the_threshold=False
    def check_limit(force,limit,fabs):
    if limit!=0:
    if(fabs)and norm(force)>=norm(limit):
    return True
    elif(not fabs)and((limit<0 and force<=limit)or(limit>0 and force>=limit)):
    return True
    else:
    return False
    end
    else:
    return False
    end
    end
    if base:
    local compareFT=bFT
    else:
    local compareFT=tFT
    end
    if(check_limit(compareFT[0],fx,force_abs)):
    is_above_the_threshold=True
    end
    if(check_limit(compareFT[1],fy,force_abs)):
    is_above_the_threshold=True
    end
    if(check_limit(compareFT[2],fz,force_abs)):
    is_above_the_threshold=True
    end
    if(check_limit(compareFT[3],tx,force_abs)):
    is_above_the_threshold=True
    end
    if(check_limit(compareFT[4],ty,force_abs)):
    is_above_the_threshold=True
    end
    if(check_limit(compareFT[5],tz,force_abs)):
    is_above_the_threshold=True
    end
    if f3d!=0 and norm(F3D)>=norm(f3d):
    is_above_the_threshold=True
    end
    if t3d!=0 and norm(T3D)>=norm(t3d):
    is_above_the_threshold=True
    end
    return is_above_the_threshold
    end
    def of_above_zero(fx=0,fy=0,fz=0,tx=0,ty=0,tz=0,zeroVal=0,base=True):
    local is_above_the_threshold=False
    def check_zero(force,axis,limit):
    if axis!=0:
    if(force>limit):
    return True
    else:
    return False
    end
    else:
    return False
    end
    end
    if base:
    local compareFT=bFT
    else:
    local compareFT=tFT
    end
    if(check_zero(compareFT[0],fx,zeroVal)):
    is_above_the_threshold=True
    end
    if(check_zero(compareFT[1],fy,zeroVal)):
    is_above_the_threshold=True
    end
    if(check_zero(compareFT[2],fz,zeroVal)):
    is_above_the_threshold=True
    end
    if(check_zero(compareFT[3],tx,zeroVal)):
    is_above_the_threshold=True
    end
    if(check_zero(compareFT[4],ty,zeroVal)):
    is_above_the_threshold=True
    end
    if(check_zero(compareFT[5],tz,zeroVal)):
    is_above_the_threshold=True
    end
    return is_above_the_threshold
    end
    of_go_new_pos=p[0,0,0,0,0,0]
    of_go_acc=0
    of_go_speed=0
    of_go_thread_flag=-1
    of_joint_move=False
    of_go_time=0
    of_go_blend=0
    of_joint_move=False
    of_go_thread_handler=0
    thread of_go_thread():
    if of_joint_move:
    movej(of_go_new_pos,a=of_go_acc,v=of_go_speed)
    else:
    movel(of_go_new_pos,a=of_go_acc,v=of_go_speed)
    end
    of_go_thread_flag= 1
    end
    def of_go(of_go_target,fx=0,fy=0,fz=0,tx=0,ty=0,tz=0,f3d=0,t3d=0,speed=0.03,acc=1.2,brake=1.2,force_abs=True,base=True,joint_move=False):
    sync()
    of_go_new_pos=of_go_target
    of_go_acc=acc
    of_go_speed=speed
    of_joint_move=joint_move
    of_go_thread_flag=0
    sync()
    if of_threshold(fx,fy,fz,tx,ty,tz,f3d,t3d,force_abs,base)==False:
    of_go_thread_flag=0
    of_go_thread_handler=run of_go_thread()
    sync()
    while(of_go_thread_flag==0):
    if of_threshold(fx,fy,fz,tx,ty,tz,f3d,t3d,force_abs,base)==False:
    sync()
    else:
    kill of_go_thread_handler
    if of_joint_move:
    stopj(brake)
    else:
    stopl(brake)
    end
    of_go_thread_flag=2
    end
    end
    end
    return of_go_thread_flag
    end
    def of_merge_poses(target,x,y,z,rx,ry,rz,base=True):
    if target==p[0,0,0,0,0,0]:
    if(x!=0 or y!=0 or z!=0 or rx!=0 or ry!=0 or rz!=0):
    local actpos=get_actual_tcp_pose()
    sync()
    local merged=of_pose_add(actpos,p[x,y,z,-rx,-ry,-rz],base)
    sync()
    return merged
    else:
    popup("Please define a valid target pose or relative movement!",title="OptoForce",error=True,blocking=False)
    halt
    end
    else:
    if(x==0 and y==0 and z==0 and rx==0 and ry==0 and rz==0):
    return target
    else:
    popup("Please define only one valid target pose or relative movement!",title="OptoForce",error=True,blocking=False)
    halt
    end
    end
    end
    def of_merge_check(target,x,y,z,rx,ry,rz,base=True):
    if target==p[0,0,0,0,0,0]:
    if(x!=0 or y!=0 or z!=0 or rx!=0 or ry!=0 or rz!=0):
    return True
    else:
    popup("Please define a valid target pose or relative movement!",title="OptoForce",error=True,blocking=True)
    return False
    end
    else:
    if(x==0 and y==0 and z==0 and rx==0 and ry==0 and rz==0):
    return True
    else:
    popup("Please define only one valid target pose or relative movement!",title="OptoForce",error=True,blocking=True)
    return False
    end
    end
    end
    of_ftpid_p_pith=0.2
    of_ftpid_i_pith=0.0
    of_ftpid_d_pith=0.0
    of_ftpid_p_pith_default=0.2
    of_ftpid_i_pith_default=0.0
    of_ftpid_d_pith_default=0.0
    of_fpid_i_pin=0.0
    of_fpid_d_pin=0.0
    of_fpid_i_pin_default=0.0
    of_fpid_d_pin_default=0.0
    of_tpid_i_pin=0.0
    of_tpid_d_pin=0.0
    of_tpid_i_pin_default=0.0
    of_tpid_d_pin_default=0.0
    of_ftpid_i_conn=0.0
    of_ftpid_d_conn=0.0
    of_tpid_div_conn=5
    of_ftpid_i_conn_default=0.0
    of_ftpid_d_conn_default=0.0
    of_tpid_div_conn_default=5
    def of_center_RxRy(AngR,TorqueXY,spdR,stateCntr=0,silent=False,base=True):
    sync()
    local state=0+stateCntr
    local retCVal=of_center(rx=AngR,t3d=TorqueXY,speed=spdR,acc=0.05,silent=True,base=base)
    if(retCVal==0):
    sync()
    elif(retCVal==1):
    state=1+stateCntr
    local retMVal=of_move_ur(rx=-AngR,tx=TorqueXY,speed=spdR,acc=0.05,silent=True,force_abs=False,base=base)
    if not silent:
    popup(of_center_rxry_return_1,title=of_fix_and_rotate_title,error=True,blocking=True)
    end
    return 1
    elif(retCVal==2):
    state=2+stateCntr
    local retMVal=of_move_ur(rx=AngR,tx=-TorqueXY,speed=spdR,acc=0.05,silent=True,force_abs=False,base=base)
    if not silent:
    popup(of_center_rxry_return_1,title=of_fix_and_rotate_title,error=True,blocking=True)
    end
    return 1
    else:
    state=3+stateCntr
    if not silent:
    popup(of_center_rxry_return_1,title=of_fix_and_rotate_title,error=True,blocking=True)
    end
    return 1
    end
    state=3+stateCntr
    retCVal=of_center(ry=AngR,t3d=TorqueXY,speed=spdR,acc=0.05,silent=True,base=base)
    if(retCVal==0):
    sync()
    elif(retCVal==1):
    state=4+stateCntr
    sync()
    local retMVal=of_move_ur(ry=-AngR,ty=TorqueXY,speed=spdR,acc=0.05,silent=True,force_abs=False,base=base)
    if not silent:
    popup(of_center_rxry_return_2,title=of_fix_and_rotate_title,error=True,blocking=True)
    end
    return 2
    elif(retCVal==2):
    state=5+stateCntr
    local retMVal=of_move_ur(ry=AngR,ty=-TorqueXY,speed=spdR,acc=0.05,silent=True,force_abs=False,base=base)
    if not silent:
    popup(of_center_rxry_return_2,title=of_fix_and_rotate_title,error=True,blocking=True)
    end
    return 2
    else:
    state=3+stateCntr
    if not silent:
    popup(of_center_rxry_return_2,title=of_fix_and_rotate_title,error=True,blocking=True)
    end
    return 2
    end
    return 0
    end
    of_peakFzScanner_flag=False
    min_bFT=[0,0,0,0,0,0]
    min0_bFT=[False,False,False,False,False,False]
    max_bFT=[0,0,0,0,0,0]
    max0_bFT=[False,False,False,False,False,False]
    abs_bFT=[0,0,0,0,0,0]
    abs0_bFT=[False,False,False,False,False,False]
    min_tFT=[0,0,0,0,0,0]
    min0_tFT=[False,False,False,False,False,False]
    max_tFT=[0,0,0,0,0,0]
    max0_tFT=[False,False,False,False,False,False]
    abs_tFT=[0,0,0,0,0,0]
    abs0_tFT=[False,False,False,False,False,False]
    min_3DFT=[0,0]
    min0_3DFT=[False,False]
    max_3DFT=[0,0]
    max0_3DFT=[False,False]
    thread of_peakFzScanner():
    of_peakFzScanner_flag=True
    abs_tFT[2]=0
    while(of_peakFzScanner_flag==True):
    i=0
    norm_tFT2=norm(tFT[2])
    if abs0_tFT[2]:
    abs_tFT[2]=0
    abs0_tFT[2]=False
    elif(abs_tFT[2]<norm_tFT2):
    abs_tFT[2]=norm_tFT2
    end
    sync()
    end
    return False
    end
    of_bi_cp_x_inv=False
    of_bi_cp_y_inv=False
    of_bi_cp_z_inv=False
    of_stack_curr_it=0
    def of_rotational_search(force,depth,surface,resolution,torque,speed=0.01,speedR=0.1,acc=0.2,silent=False):
    local base=False
    force=-norm(force)
    depth=norm(depth)
    local incr=2* MATH_PI/norm(resolution)
    local lastR=-0
    local currR=0
    textmsg("Params: ",[force,depth,incr,currR])
    local startPose=get_actual_tcp_pose()
    local nextPose=startPose
    while(norm(currR)<=(MATH_PI)):
    local retT=of_move_ur(z=depth,fz=force,speed=speed,acc=acc,brake=1000,silent=True,force_abs=True,base=base)
    if(retT==1):
    local holePose=of_pose_add(nextPose,p[0,0,depth*surface,0,0,0],base)
    local retF=of_move_ur(target=holePose,fz=-force,speed=speed,acc=acc,brake=1000,silent=True,force_abs=False,base=base)
    if(retF!=1):
    if not silent:
    popup("Collision occured during the moveback mevement!",title="OptoForce",error=True,blocking=True)
    end
    return 4
    else:
    return 0
    end
    elif(retT==2):
    local retM=of_move_ur(target=nextPose,fz=-force,speed=speed,acc=acc,brake=1000,silent=True,force_abs=False,base=base)
    if(retM!=1):
    if not silent:
    popup("Collision occured during the moveback mevement!",title="OptoForce",error=True,blocking=True)
    end
    return 2
    end
    if(-lastR==currR):
    lastR=currR
    if(currR<0):
    currR=currR-incr
    else:
    currR=currR+incr
    end
    else:
    lastR=currR
    currR=-currR
    end
    nextPose=of_pose_add(startPose,p[0,0,0,0,0,currR],base)
    local retR=of_move_ur(target=nextPose,tz=torque,speed=speedR,acc=acc,brake=1000,silent=True,force_abs=True,base=base)
    if(retR!=1):
    if not silent:
    popup("Collision occured during the rotational mevement!",title="OptoForce",error=True,blocking=True)
    end
    return 3
    end
    else:
    if not silent:
    popup("The try movement can not been started!",title="OptoForce",error=True,blocking=True)
    end
    return 1
    end
    end
    if not silent:
    popup("The rotational search was unsuccessful with this resolution!",title="OptoForce",error=True,blocking=True)
    end
    return 5
    end
  
    #=============================================#
    #======    End of OptoForce Elements    ======#
    #=============================================#
  
    #===================================================#
    #======    Start of OptoForce Applications    ======#
    #===================================================#
  
    def of_move_ur(target=p[0,0,0,0,0,0],x=0,y=0,z=0,rx=0,ry=0,rz=0,fx=0,fy=0,fz=0,tx=0,ty=0,tz=0,f3d=0,t3d=0,speed=0.05,acc=1.2,brake=1.2,silent=False,force_abs=True,base=True,joint_move=False):
    sync()
    target=of_merge_poses(target,x,y,z,rx,ry,rz,base)
    sync()
    local ret=of_go(target,fx,fy,fz,tx,ty,tz,f3d,t3d,speed,acc,brake,force_abs,base,joint_move)
    if not silent:
    if ret==0:
    popup(of_move_move_return_2,title="OptoForce - UR Move error",error=True,blocking=True)
    elif ret==2:
    popup(of_move_move_return_1,title="OptoForce - UR Move error",error=True,blocking=True)
    end
    end
    return ret
    end
    def of_search_ur(target=p[0,0,0,0,0,0],x=0,y=0,z=0,rx=0,ry=0,rz=0,fx=0,fy=0,fz=0,tx=0,ty=0,tz=0,f3d=0,t3d=0,speed=0.03,acc=1.2,brake=1.2,silent=False,force_abs=True,base=True):
    sync()
    target=of_merge_poses(target,x,y,z,rx,ry,rz,base)
    sync()
    local ret=of_go(target,fx,fy,fz,tx,ty,tz,f3d,t3d,speed,acc,brake,force_abs,base)
    if not silent:
    if ret==0:
    popup(of_move_search_return_2,title="OptoForce - UR Search error",error=True,blocking=True)
    elif ret==1:
    popup(of_move_search_return_1,title="OptoForce - UR Search error",error=True,blocking=True)
    end
    end
    return ret
    end
    def of_center(x=0,y=0,z=0,rx=0,ry=0,rz=0,fx=0,fy=0,fz=0,tx=0,ty=0,tz=0,f3d=0,t3d=0,speed=0.03,speedCP=99999,acc=0.2,brake=1.2,silent=False,force_abs=True,base=True):
    sync()
    if speedCP==99999:
    speedCP=speed
    end
    def invert_offset(o):
    local i=0
    local r=p[0,0,0,0,0,0]
    while(i<6):
    if(o[i]!=0):
    r[i]=-o[i]
    else:
    r[i]=0
    end
    i=i+1
    end
    return r
    end
    local search3D=False
    local db=0
    if x!=0:
    db=db+1
    end
    if y!=0:
    db=db+1
    end
    if z!=0:
    db=db+1
    end
    if rx!=0:
    db=db+1
    end
    if ry!=0:
    db=db+1
    end
    if rz!=0:
    db=db+1
    end
    if db==0:
    popup(of_center_return_99,title=of_center_title,error=True,blocking=True)
    return 99
    end
    if db>1:
    popup(of_center_return_99,title=of_center_title,error=True,blocking=True)
    return 99
    end
    sync()
    if f3d!=0:
    force_abs=True
    search3D=True
    if(fx==0 and fy==0 and fz==0):
    fx=f3d*0.57735
    fy=fx
    fz=fx
    end
    f3d=norm(f3d)
    end
    if t3d!=0:
    force_abs=True
    search3D=True
    if(tx==0 and ty==0 and tz==0):
    tx=t3d*0.57735
    ty=tx
    tz=tx
    end
    t3d=norm(t3d)
    end
    local offset=p[x,y,z,-rx,-ry,-rz]
    if(force_abs):
    fx=norm(fx)
    fy=norm(fy)
    fz=norm(fz)
    tx=norm(tx)
    ty=norm(ty)
    tz=norm(tz)
    else:
    local reverse=of_threshold(fx,fy,fz,tx,ty,tz,force_abs=False,base=base)
    if reverse:
    offset=invert_offset(offset)
    fx=-fx
    fy=-fy
    fz=-fz
    tx=-tx
    ty=-ty
    tz=-tz
    end
    end
    sync()
    local start_wp=get_actual_tcp_pose()
    local target=of_pose_add(start_wp,offset,base)
    of_wait_ms(200)
    sync()
    local ret=of_search_ur(target=target,fx=fx,fy=fy,fz=fz,tx=tx,ty=ty,tz=tz,f3d=f3d,t3d=t3d,speed=speed,acc=acc,brake=brake,silent=True,force_abs=force_abs,base=base)
    if ret!=1:
    sync()
    if(ret==0 and force_abs==True):
    if not silent:
    popup(of_center_return_4,title=of_center_title,error=True,blocking=True)
    end
    return 4
    end
    local pose1=get_actual_tcp_pose()
    of_wait_ms(200)
    sync()
    if(force_abs):
    local mret=0
    if(search3D):
    mret=of_search_ur(target=start_wp,f3d=3*f3d,t3d=3*t3d,speed=speed,acc=acc,brake=brake,silent=True,force_abs=True,base=base)
    else:
    local aboveZ=of_above_zero(fx,fy,fz,tx,ty,tz,0,base)
    sync()
    if(aboveZ):
    mret=of_search_ur(target=start_wp,fx=-fx,fy=-fy,fz=-fz,tx=-tx,ty=-ty,tz=-tz,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    else:
    mret=of_search_ur(target=start_wp,fx=fx,fy=fy,fz=fz,tx=tx,ty=ty,tz=tz,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    end
    end
    sync()
    if mret!=1:
    if mret==0:
    if not silent:
    popup(of_center_return_5,title=of_center_title,error=True,blocking=True)
    end
    return 5
    end
    sync()
    local pose2=get_actual_tcp_pose()
    local poseC=interpolate_pose(pose1,pose2,0.5)
    sync()
    if(search3D):
    mret=of_move_ur(poseC,f3d=6*f3d,t3d=6*t3d,speed=speed,acc=acc,brake=brake,silent=True,force_abs=True,base=base)
    else:
    local aboveZ=of_above_zero(fx,fy,fz,tx,ty,tz,0,base)
    if(aboveZ):
    mret=of_move_ur(poseC,fx=3*fx,fy=3*fy,fz=3*fz,tx=3*tx,ty=3*ty,tz=3*tz,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    else:
    mret=of_move_ur(poseC,fx=-3*fx,fy=-3*fy,fz=-3*fz,tx=-3*tx,ty=-3*ty,tz=-3*tz,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    end
    end
    if mret==1:
    return 0
    else:
    if not silent:
    popup(of_center_return_3,title=of_center_title,error=True,blocking=True)
    end
    return 3
    end
    end
    end
    sync()
    local offset2=invert_offset(offset)
    sync()
    target=of_pose_add(start_wp,offset2,base)
    sync()
    local ret2=of_search_ur(target,fx=-fx,fy=-fy,fz=-fz,tx=-tx,ty=-ty,tz=-tz,f3d=f3d,t3d=t3d,speed=speed,acc=acc,brake=brake,silent=True,force_abs=force_abs,base=base)
    if ret2!=1:
    sync()
    local pose2=get_actual_tcp_pose()
    local poseC=interpolate_pose(pose1,pose2,0.5)
    local mret=0
    of_wait_ms(200)
    sync()
    if(force_abs):
    if(search3D):
    mret=of_move_ur(poseC,f3d=3*f3d,t3d=3*t3d,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    else:
    local aboveZ=of_above_zero(fx,fy,fz,tx,ty,tz,0,base)
    if(aboveZ):
    mret=of_move_ur(poseC,fx=-fx,fy=-fy,fz=-fz,tx=-tx,ty=-ty,tz=-tz,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    else:
    mret=of_move_ur(poseC,fx=fx,fy=fy,fz=fz,tx=tx,ty=ty,tz=tz,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    end
    end
    else:
    mret=of_move_ur(poseC,fx=fx,fy=fy,fz=fz,tx=tx,ty=ty,tz=tz,speed=speedCP,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    end
    sync()
    if mret==1:
    return 0
    else:
    if not silent:
    popup(of_center_return_3,title=of_center_title,error=True,blocking=True)
    end
    return 3
    end
    else:
    if not silent:
    popup(of_center_return_2,title=of_center_title,error=True,blocking=True)
    end
    return 2
    end
    else:
    if not silent:
    popup(of_center_return_1,title=of_center_title,error=True,blocking=True)
    end
    return 1
    end
    end
    def of_pin_insertion(minDistZ,forceZ,compliance=[True,True,True,True,True,True],maxDistZ=0,expSpeed=0,deltaForce=1,timeOut=0,FTLimits=[999,0,999,999,999,999],PGainF=1.0,PGainT=1.0,silent=False):
    sync()
    local pinRet=0
    if not(minDistZ>=0):
    popup(of_pin_insertion_param_error_minDistZ,title=of_pin_insertion_param_error_title,error=True,blocking=True)
    pinRet=8
    elif not(forceZ>0):
    popup(of_pin_insertion_param_error_forceZ,title=of_pin_insertion_param_error_title,error=True,blocking=True)
    pinRet=8
    elif not(maxDistZ>=0):
    popup(of_pin_insertion_param_error_maxDistZ,title=of_pin_insertion_param_error_title,error=True,blocking=True)
    pinRet=8
    elif not(maxDistZ>=minDistZ or maxDistZ==0):
    popup(of_pin_insertion_param_error_maxDistZ_minDistZ,title=of_pin_insertion_param_error_title,error=True,blocking=True)
    pinRet=8
    elif not(expSpeed>=0):
    popup(of_pin_insertion_param_error_expSpeed,title=of_pin_insertion_param_error_title,error=True,blocking=True)
    pinRet=8
    elif not(deltaForce>=0):
    popup(of_pin_insertion_param_error_deltaForce,title=of_pin_insertion_param_error_title,error=True,blocking=True)
    pinRet=8
    elif not(timeOut>=0):
    popup(of_pin_insertion_param_error_timeOut,title=of_pin_insertion_param_error_title,error=True,blocking=True)
    pinRet=8
    elif not(FTLimits[0]>=0):
    popup(of_pin_insertion_param_error_FTLimits,title=of_pin_insertion_param_error_title,error=True,blocking=True)
    pinRet=8
    elif not(FTLimits[1]>=0):
    popup(of_pin_insertion_param_error_FTLimits,title=of_pin_insertion_param_error_title,error=True,blocking=True)
    pinRet=8
    elif not(FTLimits[3]>=0):
    popup(of_pin_insertion_param_error_FTLimits,title=of_pin_insertion_param_error_title,error=True,blocking=True)
    pinRet=8
    elif not(FTLimits[4]>=0):
    popup(of_pin_insertion_param_error_FTLimits,title=of_pin_insertion_param_error_title,error=True,blocking=True)
    pinRet=8
    elif not(FTLimits[5]>=0):
    popup(of_pin_insertion_param_error_FTLimits,title=of_pin_insertion_param_error_title,error=True,blocking=True)
    pinRet=8
    elif not(PGainF>0):
    popup(of_pin_insertion_param_error_PGainF,title=of_pin_insertion_param_error_title,error=True,blocking=True)
    pinRet=8
    elif not(PGainT>0):
    popup(of_pin_insertion_param_error_PGainT,title=of_pin_insertion_param_error_title,error=True,blocking=True)
    pinRet=8
    end
    if(pinRet!=0):
    return pinRet
    end
    of_tcp_offset_send()
    local frameID=1
    local base=False
    local startPose=get_actual_tcp_pose()
    if maxDistZ==0:
    maxDistZ=minDistZ
    end
    local dist2Reach=maxDistZ
    sync()
    local ft_select=compliance
    ft_select[2]=True
    local ft_values=[0,0,0,0,0,0]
    ft_values[2]=forceZ
    local ft_threshold=FTLimits
    ft_threshold[2]=0
    i=0
    while i<6:
    if ft_select[i]:
    ft_threshold[i]=0
    end
    i=i+1
    end
    local pin_useTimeOut=True
    if timeOut==0:
    pin_useTimeOut=False
    end
    local timeOut100ms=timeOut*10
    local deltaD=expSpeed/10
    global of_pin_currentDist=0
    local peakScanner=run of_peakFzScanner()
    sync()
    local pin_forcePID=[PGainF,of_fpid_i_pin,of_fpid_d_pin]
    local pin_torquePID=[PGainT,of_tpid_i_pin,of_tpid_d_pin]
    of_ft_control_start(ft_select=ft_select,ft_values=ft_values,frameID=frameID,frameRPY=[0,0,0],forcePID=pin_forcePID,torquePID=pin_torquePID,deviation_max=0)
    local cntr=0
    local leaveInsertion=False
    local bumpZeroPeak=True
    local pin_actual_pose=get_actual_tcp_pose()
    of_pin_currentDist=point_dist(startPose,pin_actual_pose)
    local pin_last_pose=pin_actual_pose
    global actual_deltaD=deltaD
    while((of_pin_currentDist<dist2Reach)and not leaveInsertion):
    of_wait_ms(100)
    pin_actual_pose=get_actual_tcp_pose()
    of_pin_currentDist=point_dist(startPose,pin_actual_pose)
    actual_deltaD=(actual_deltaD+pose_dist(pin_last_pose,pin_actual_pose))/2
    if(of_threshold(fx=ft_threshold[0],fy=ft_threshold[1],fz=0,tx=ft_threshold[3],ty=ft_threshold[4],tz=ft_threshold[5],force_abs=True,base=base)):
    leaveInsertion=True
    if(of_pin_currentDist<minDistZ):
    pinRet=7
    else:
    pinRet=6
    end
    of_ft_control_stop()
    if not silent:
    popup(of_pin_insertion_exit_maxSideFT,title=of_pin_insertion_exit_title,warning=True,blocking=True)
    end
    elif(pin_useTimeOut and(cntr>timeOut100ms)):
    leaveInsertion=True
    if(of_pin_currentDist<minDistZ):
    pinRet=5
    else:
    pinRet=4
    end
    of_ft_control_stop()
    if not silent:
    popup(of_pin_insertion_exit_timeOut,title=of_pin_insertion_exit_title,warning=True,blocking=True)
    end
    elif(actual_deltaD<deltaD and cntr>=10):
    leaveInsertion=True
    if(of_pin_currentDist<minDistZ):
    pinRet=3
    of_ft_control_stop()
    if not silent:
    popup(of_pin_insertion_exit_deltaD,title=of_pin_insertion_exit_title,warning=True,blocking=True)
    end
    else:
    pinRet=2
    end
    elif(of_pin_currentDist>=minDistZ):
    if bumpZeroPeak:
    bumpZeroPeak=False
    abs0_tFT[2]=True
    sync()
    else:
    if(abs_tFT[2]>norm(forceZ+deltaForce)and not abs0_tFT[2]):
    of_peakFzScanner_flag=False
    leaveInsertion=True
    pinRet=1
    end
    end
    end
    pin_last_pose=pin_actual_pose
    cntr=cntr+1
    sync()
    end
    of_ft_control_stop()
    of_peakFzScanner_flag=False
    kill peakScanner
    of_fpid_i_pin=of_fpid_i_pin_default
    of_fpid_d_pin=of_fpid_d_pin_default
    of_tpid_i_pin=of_tpid_i_pin_default
    of_tpid_d_pin=of_tpid_d_pin_default
    return pinRet
    end
    def of_connector_insertion(distZ,forceZ,forceXY_en0=[True,True],torqueXYZ_en0=[True,True,True],torqueXY=0.1,angR=0.175,speedR=0.01,alpha=0.1,omega=0.4,centeringRate=15,bumpRelative=1,deltaForce=1,PID_Gain=0.5,silent=False,base=True):
    sync()
    of_tcp_offset_send()
    local state=1
    local startPose=get_actual_tcp_pose()
    global of_conn_dist2Reach=distZ
    local dist2StartC=alpha*distZ
    local dist2EndC=omega*distZ
    local forceXY=[0,0]
    local torqueXYZ=[0,0,0]
    local frameID=0
    sync()
    local i=0
    while i<2:
    if forceXY_en0[i]:
    forceXY[i]=0.001
    else:
    forceXY[i]=0
    end
    i=i+1
    end
    i=0
    while i<3:
    if torqueXYZ_en0[i]:
    torqueXYZ[i]=0.0001
    else:
    torqueXYZ[i]=0
    end
    i=i+1
    end
    sync()
    if base:
    forceZ=-norm(forceZ)
    deltaForce=-norm(deltaForce)
    frameID=0
    else:
    forceZ=norm(forceZ)
    deltaForce=norm(deltaForce)
    frameID=1
    end
    angR=norm(angR)
    torqueXY=norm(torqueXY)
    global of_conn_currentDist=0
    sync()
    local peakScanner=run of_peakFzScanner()
    sync()
    local conn_forcePID=[PID_Gain,of_ftpid_i_conn,of_ftpid_d_conn]
    local conn_torquePID=[PID_Gain/of_tpid_div_conn,of_ftpid_i_conn/of_tpid_div_conn,of_ftpid_d_conn/of_tpid_div_conn]
    of_ft_control_start(ft_select=[forceXY_en0[0],forceXY_en0[1],True,torqueXYZ_en0[0],torqueXYZ_en0[1],torqueXYZ_en0[2]],ft_values=[forceXY[0],forceXY[1],forceZ,torqueXYZ[0],torqueXYZ[1],torqueXYZ[2]],frameID=frameID,frameRPY=[0,0,0],forcePID=conn_forcePID,torquePID=conn_torquePID,deviation_max=0)
    of_wait_ms(300)
    local cntr=0
    local bumpEnd=False
    local bumpZeroPeak=True
    of_conn_currentDist=point_dist(startPose,get_actual_tcp_pose())
    while((of_conn_currentDist<distZ)and not bumpEnd):
    if(cntr>centeringRate):
    of_ft_control_stop()
    sync()
    if((of_conn_currentDist>dist2StartC)and(of_conn_currentDist<dist2EndC)):
    local SpeedR=speedR*(1-0.75*of_conn_currentDist/of_conn_dist2Reach)
    local retVal=of_center_RxRy(angR,torqueXY,SpeedR,stateCntr=(cntr*10),silent=silent,base=base)
    sync()
    if(retVal!=0):
    kill peakScanner
    of_ftpid_i_conn=of_ftpid_i_conn_default
    of_ftpid_d_conn=of_ftpid_d_conn_default
    of_tpid_div_conn=of_tpid_div_conn_default
    return retVal
    end
    end
    cntr=0
    if forceXY_en0:
    forceXY=[-1*forceXY[0],-1*forceXY[1]]
    end
    if torqueXYZ_en0:
    torqueXYZ=[-1*torqueXYZ[0],-1*torqueXYZ[1],-1*torqueXYZ[2]]
    end
    of_ft_control_start(ft_select=[forceXY_en0[0],forceXY_en0[1],True,torqueXYZ_en0[0],torqueXYZ_en0[1],torqueXYZ_en0[2]],ft_values=[forceXY[0],forceXY[1],forceZ,torqueXYZ[0],torqueXYZ[1],torqueXYZ[2]],frameID=frameID,frameRPY=[0,0,0],forcePID=conn_forcePID,torquePID=conn_torquePID,deviation_max=0)
    end
    of_wait_ms(100)
    cntr=cntr+1
    of_conn_currentDist=point_dist(startPose,get_actual_tcp_pose())
    sync()
    if(of_conn_currentDist>(distZ*bumpRelative)):
    if bumpZeroPeak:
    bumpZeroPeak=False
    abs0_tFT[2]=True
    sync()
    end
    if base:
    if(bFT[2]>norm(forceZ+deltaForce)):
    bumpEnd=True
    of_peakFzScanner_flag=False
    end
    else:
    if(abs_tFT[2]>norm(forceZ+deltaForce)):
    bumpEnd=True
    of_peakFzScanner_flag=False
    end
    end
    end
    sync()
    end
    sync()
    of_ft_control_stop()
    kill peakScanner
    of_ftpid_i_conn=of_ftpid_i_conn_default
    of_ftpid_d_conn=of_ftpid_d_conn_default
    of_tpid_div_conn=of_tpid_div_conn_default
    return 0
    end
    def of_fix_and_rotate(rotateZ,torqueZ,distZ,forceZ,forceXY_en0=[True,True],torqueXYZ_en0=[True,True,True],torqueXY=0.1,angR=0.175,speedR=0.01,alpha=0.1,omega=0.4,centeringRate=15,bumpRelative=1.0,deltaForce=1,PID_Gain=0.5,rotateEndSearch=1.0,torqueEndSearch=9999,silent=False,base=True):
    if rotateEndSearch<0 and rotateEndSearch>1.0:
    popup(of_fix_and_rotate_param_error,title=of_fix_and_rotate_title,error=True,blocking=True)
    return 99
    end
    if torqueEndSearch==9999:
    torqueEndSearch=torqueZ/2
    end
    local moveRz=rotateZ*rotateEndSearch
    local searchRz=rotateZ*norm(1-rotateEndSearch)
    local retConn=of_connector_insertion(distZ,forceZ,forceXY_en0,torqueXYZ_en0,torqueXY,angR,speedR,alpha,omega,centeringRate,bumpRelative,deltaForce,PID_Gain,silent,base=base)
    local retM=0
    if(retConn==0):
    if(rotateZ!=0):
    if(moveRz!=0):
    retM=of_move_ur(rz=moveRz,tz=torqueZ,speed=speedR,acc=speedR*3,silent=True,force_abs=True,base=base)
    else:
    retM=1
    end
    if(retM!=1):
    if not silent:
    popup(of_fix_and_rotate_return_21,title=of_fix_and_rotate_title,error=True,blocking=True)
    end
    return 21
    else:
    local retS=0
    if(searchRz!=0):
    retS=of_search_ur(rz=searchRz,tz=torqueEndSearch,speed=speedR,acc=speedR*3,silent=True,force_abs=True,base=base)
    else:
    retS=0
    end
    if(retS==1 and rotateEndSearch<1.0):
    if not silent:
    popup(of_fix_and_rotate_return_22,title=of_fix_and_rotate_title,error=True,blocking=True)
    end
    return 22
    else:
    return 0
    end
    end
    else:
    return 0
    end
    else:
    return 10+retConn
    end
    end
    def of_box_ins(x1=0,y1=0,z1=0,x2=0,y2=0,z2=0,rx=0,ry=0,rz=0,speed=0.03,acc=0.5,brake=2,force=2,torque=0.3,silent=False,insert_force_multiplier=1.5,depth=0,base=True):
    def calc_3d_forces(force,x,y,z,filtering=True):
    local fnorm=sqrt(x*x+y*y+z*z)
    local forces=[-force*x/fnorm,-force*y/fnorm,-force*z/fnorm]
    if not filtering:
    return forces
    end
    i=0
    while i<3:
    if norm(forces[i])<0.1:
    forces[i]=0
    end
    i=i+1
    end
    return forces
    end
    local start_pose=get_actual_tcp_pose()
    sync()
    local ret=of_move_ur(rx=rx,ry=ry,rz=rz,f3d=force*2,t3d=torque*2,speed=speed,acc=acc,brake=brake,silent=True,base=base)
    if ret!=1:
    if not silent:
    popup(of_box_ins_return_4,title=of_box_ins_title,error=True,blocking=True)
    end
    return 4
    end
    sync()
    local fdir=calc_3d_forces(force,x1,y1,z1)
    local m3d=[x1,y1,z1]
    if base==False:
    fdir=of_rotate_qu(fdir,of_rotvec2qu([-rx,-ry,-rz]))
    m3d=of_rotate_qu([x1,y1,z1],of_rotvec2qu([-rx,-ry,-rz]))
    end
    sync()
    ret=of_search_ur(x=m3d[0],y=m3d[1],z=m3d[2],fx=fdir[0],fy=fdir[1],fz=fdir[2],t3d=torque,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    if ret==1:
    if not silent:
    popup(of_box_ins_return_1,title=of_box_ins_title,error=True,blocking=True)
    end
    return 1
    end
    sync()
    if x2!=0 or y2!=0 or z2!=0:
    fdir=calc_3d_forces(force,x2,y2,z2)
    ret=of_search_ur(x=x2,y=y2,z=z2,fx=fdir[0],fy=fdir[1],fz=fdir[2],t3d=2*torque,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    if ret==1:
    if not silent:
    popup(of_box_ins_return_2,title=of_box_ins_title,error=True,blocking=True)
    end
    return 2
    end
    end
    local apos=get_actual_tcp_pose()
    ret=of_move_ur(p[apos[0],apos[1],apos[2],start_pose[3],start_pose[4],start_pose[5]],f3d=insert_force_multiplier*force,t3d=insert_force_multiplier*torque,speed=speed,acc=acc,brake=brake,silent=True,base=base)
    if ret!=1:
    if not silent:
    popup(of_box_ins_return_3,title=of_box_ins_title,error=True,blocking=True)
    end
    return 3
    end
    sync()
    if depth!=0:
    fdir=calc_3d_forces(insert_force_multiplier*force,x1,y1,z1)
    local inserted=False
    local collisions=0
    while not inserted:
    sync()
    local current_dist=pose_dist(get_actual_tcp_pose(),start_pose)
    local move3d=calc_3d_forces(depth-current_dist,-x1,-y1,-z1,filtering=False)
    ret=of_move_ur(x=move3d[0],y=move3d[1],z=move3d[2],fx=fdir[0],fy=fdir[1],fz=fdir[2],t3d=insert_force_multiplier*torque,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    if ret==2 or ret==0:
    collisions=collisions+1
    if collisions>5:
    if not silent:
    popup(of_box_ins_return_8,title=of_box_ins_title,error=True,blocking=True)
    end
    return 8
    end
    if move3d[0]==0:
    if of_bi_cp_x_inv:
    of_cp_inv=True
    end
    ret=of_center(x=depth,f3d=insert_force_multiplier*force,t3d=insert_force_multiplier*torque,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    of_cp_inv=False
    if ret!=0:
    if not silent:
    popup(of_box_ins_return_5,title=of_box_ins_title,error=True,blocking=True)
    end
    return 5
    end
    end
    if move3d[1]==0:
    if of_bi_cp_y_inv:
    of_cp_inv=True
    end
    ret=of_center(y=depth,f3d=insert_force_multiplier*force,t3d=insert_force_multiplier*torque,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    of_cp_inv=False
    if ret!=0:
    if not silent:
    popup(of_box_ins_return_6,title=of_box_ins_title,error=True,blocking=True)
    end
    return 6
    end
    end
    if move3d[2]==0:
    if of_bi_cp_z_inv:
    of_cp_inv=True
    end
    ret=of_center(z=depth,f3d=insert_force_multiplier*force,t3d=insert_force_multiplier*torque,speed=speed,acc=acc,brake=brake,silent=True,force_abs=False,base=base)
    of_cp_inv=False
    if ret!=0:
    if not silent:
    popup(of_box_ins_return_7,title=of_box_ins_title,error=True,blocking=True)
    end
    return 7
    end
    end
    elif ret==1:
    inserted=True
    end
    end
    end
    return 0
    end
    def of_stacking(start_wp,thickness,it,it_max=0,x=0,y=0,z=0,f3d=0,t3d=0,moveF3D=9999,moveT3D=9999,speed=0.03,moveSpd=0.05,acc=1.2,brake=1.2,move2Start=False,silent=False,base=True):
    local stack_wp=start_wp
    of_stack_curr_it=it
    if(moveF3D==9999):
    moveF3D=2*f3d
    end
    if(moveT3D==9999):
    moveT3D=2*t3d
    end
    if(it_max==0):
    if(thickness==0):
    it=it_max-1
    else:
    it_max=floor(norm((x+y+z)/thickness))
    end
    elif(it_max>norm((x+y+z)/thickness)):
    popup(of_stacking_param_error_itmax,title=of_stacking_title,error=True,blocking=True)
    return 995
    elif(thickness==0):
    popup(of_stacking_param_error_thickness,title=of_stacking_title,error=True,blocking=True)
    return 990
    end
    local it_end=floor(norm((x+y+z)/thickness))
    local delta=0
    local deltaMax=0
    if(thickness>0):
    delta=norm(thickness*(it_end-of_stack_curr_it-1))
    elif(thickness<0):
    delta=norm(thickness*of_stack_curr_it)
    end
    local offset=p[0,0,0,0,0,0]
    local db=0
    if x!=0:
    db=db+1
    offset=p[delta*x/norm(x),0,0,0,0,0]
    offsetMax=p[x,0,0,0,0,0]
    end
    if y!=0:
    db=db+1
    offset=p[0,delta*y/norm(y),0,0,0,0]
    offsetMax=p[0,y,0,0,0,0]
    end
    if z!=0:
    db=db+1
    offset=p[0,0,delta*z/norm(z),0,0,0]
    offsetMax=p[0,0,z,0,0,0]
    end
    if db==0:
    popup(of_stacking_param_error_dir,title=of_stacking_title,error=True,blocking=True)
    return 991
    end
    if db>1:
    popup(of_stacking_param_error_dir,title=of_stacking_title,error=True,blocking=True)
    return 990+db
    end
    if delta==0.0:
    offset=p[0,0,0,0,0,0]
    end
    if move2Start:
    local mRet=of_move_ur(target=start_wp,f3d=moveF3D,t3d=moveT3D,speed=moveSpd,acc=acc,brake=brake,silent=True,force_abs=True,base=base)
    if(mRet!=1):
    if not silent:
    popup(of_stacking_return_5,title=of_stacking_title,error=True,blocking=True)
    end
    return 5
    end
    end
    if(it>=it_max):
    if not silent:
    if(thickness>0):
    popup(of_stacking_return_1_stack,title=of_stacking_title,error=True,blocking=True)
    else:
    popup(of_stacking_return_1_destack,title=of_stacking_title,error=True,blocking=True)
    end
    end
    of_stack_curr_it=0
    return 1
    end
    stack_wp=of_pose_add(start_wp,offset,base)
    local stack_max_wp=of_pose_add(start_wp,offsetMax,base)
    local mRet=of_move_ur(target=stack_wp,f3d=moveF3D,t3d=moveT3D,speed=moveSpd,acc=acc,brake=brake,silent=True,force_abs=True,base=base)
    if(mRet!=1):
    if not silent:
    popup(of_stacking_return_4,title=of_stacking_title,error=True,blocking=True)
    end
    return 4
    end
    local sRet=of_search_ur(target=stack_max_wp,f3d=f3d,t3d=t3d,speed=speed,acc=acc,brake=brake,silent=True,force_abs=True,base=base)
    if(sRet==2):
    elif(sRet==1):
    if not silent:
    popup(of_stacking_return_2,title=of_stacking_title,error=True,blocking=True)
    end
    return 2
    else:
    if not silent:
    popup(of_stacking_return_3,title=of_stacking_title,error=True,blocking=True)
    end
    return 3
    end
    of_stack_curr_it=of_stack_curr_it+1
    return 0
    end
    def of_stacking_last_it():
    return of_stack_curr_it
    end
    def of_get_virt_orient(virt_pose):
    local retVal=[virt_pose[3],virt_pose[4],virt_pose[5]]
    textmsg("virt_orient: ",retVal)
    return retVal
    end
    def of_polishing(forceAmp,forceDir,pidGain=[1.0,1.0,1.0]):
    local force_orient=of_get_virt_orient(forceDir)
    local frameRotVec=rpy2rotvec(force_orient)
    of_ft_control_start(ft_select=[False,False,True,False,False,False],ft_values=[0,0,forceAmp,0,0,0],frameID=0,frameRPY=frameRotVec,forcePID=pidGain,torquePID=pidGain,deviation_max=0)
    end
  
    #=================================================#
    #======    End of OptoForce Applications    ======#
    #=================================================#
  # end: URCap Installation Node
  # begin: URCap Installation Node
  #   Source: Robotiq_Grippers, 1.3.0, Robotiq Inc.
  #   Type: Gripper
  
  ###########################################
  #######Gripper URCap preamble start########
  #######Version null########
  
  #aliases for the gripper variable names
  ACT = 1
  GTO = 2
  ATR = 3
  ARD = 4
  FOR = 5
  SPE = 6
  OBJ = 7
  STA = 8
  FLT = 9
  POS = 10
  PRE = 11
  
  def rq_init_connection(gripper_sid=9, gripper_socket="1"):
  	socket_open("127.0.0.1",63352, gripper_socket)
  	socket_set_var("SID", gripper_sid,  gripper_socket)
  	ack = socket_read_byte_list(3, gripper_socket)
  end
  
  def rq_set_sid(gripper_sid=9, gripper_socket="1"):
          socket_set_var("SID", gripper_sid,  gripper_socket)
          sync()
          return is_ack(socket_read_byte_list(3, gripper_socket))
  end
  
  def rq_activate(gripper_socket="1"):
  	rq_gripper_act = 0
  
      if (not rq_is_gripper_activated(gripper_socket)):
         rq_reset(gripper_socket)
  
         while(socket_get_var("ACT",gripper_socket) == 1):
            sleep(0.1)
            rq_reset(gripper_socket)
         end
      end
  
  	rq_set_var(ACT,1, gripper_socket)
  end
  
  def rq_activate_and_wait(gripper_socket="1"):
  	rq_activate(gripper_socket)
  
  	while(not rq_is_gripper_activated(gripper_socket)):
  		# wait for activation completed
  	end
  end
  
  def rq_stop(gripper_socket="1"):
  	rq_set_var(GTO,0, gripper_socket)
  end
  
  def rq_reset(gripper_socket="1"):
  	rq_gripper_act = 0
  	rq_obj_detect = 0
  	rq_mov_complete = 0
  
  	rq_set_var(ACT,0, gripper_socket)
  	rq_set_var(ATR,0, gripper_socket)
  end
  
  def rq_auto_release_open_and_wait(gripper_socket="1"):
  	rq_set_var(ARD,0, gripper_socket)
  	rq_set_var(ACT,1, gripper_socket)
  	rq_set_var(ATR,1, gripper_socket)
  
  	gFLT = rq_get_var(FLT, 2, gripper_socket)
  
  	while(not is_FLT_autorelease_completed(gFLT)):
  		gFLT = rq_get_var(FLT, 2, gripper_socket)
  	end
  end
  
  def rq_auto_release_close_and_wait(gripper_socket="1"):
  	rq_set_var(ARD,1, gripper_socket)
  	rq_set_var(ACT,1, gripper_socket)
  	rq_set_var(ATR,1, gripper_socket)
  
  	gFLT = rq_get_var(FLT, 2, gripper_socket)
  
  	while(not is_FLT_autorelease_completed(gFLT)):
  		gFLT = rq_get_var(FLT, 2, gripper_socket)
  	end
  end
  
  def rq_set_force(force, gripper_socket="1"):
  	rq_set_var(FOR,force, gripper_socket)
  end
  
  def rq_set_speed(speed, gripper_socket="1"):
  	rq_set_var(SPE,speed, gripper_socket)
  end
  
  def rq_open(gripper_socket="1"):
  	rq_move(0, gripper_socket)
  end
  
  def rq_close(gripper_socket="1"):
  	rq_move(255, gripper_socket)
  end
  
  def rq_open_and_wait(gripper_socket="1"):
  	rq_move_and_wait(0, gripper_socket)
  end
  
  def rq_close_and_wait(gripper_socket="1"):
  	rq_move_and_wait(255, gripper_socket)
  end
  
  def rq_move(pos, gripper_socket="1"):
  	rq_mov_complete = 0
  	rq_obj_detect = 0
  
  	rq_set_pos(pos, gripper_socket)
  	rq_go_to(gripper_socket)
  end
  
  def rq_move_and_wait(pos, gripper_socket="1"):
  	rq_move(pos, gripper_socket)
  
  	while (not rq_is_motion_complete(gripper_socket)):
  		# wait for motion completed
  		sleep(0.01)
  		sync()
  	end
  
  	# following code used for compatibility with previous versions
  	rq_is_object_detected(gripper_socket)
  
  	if (rq_obj_detect != 1):
  		rq_mov_complete = 1
  	end
  end
  
  def rq_wait_for_pos(pos, gripper_socket="1"):
  	gPRE = rq_get_var(PRE, 3, gripper_socket)
  	pre = (gPRE[1] - 48)*100 + (gPRE[2] -48)*10 + gPRE[3] - 48
  
  	while (pre != pos):
          rq_set_var(POS, pos, gripper_socket)
  		gPRE = rq_get_var(PRE, 3, gripper_socket)
  		pre = (gPRE[1] - 48)*100 + (gPRE[2] -48)*10 + gPRE[3] - 48
  		sync()
  	end
  
      # Wait for the gripper motion to complete
      while (not rq_is_motion_complete(gripper_socket)):
  		# wait for motion completed
  		sleep(0.01)
  		sync()
  	end
  
  	# following code used for compatibility with previous versions
  	rq_is_object_detected(gripper_socket)
  
  	if (rq_obj_detect != 1):
  		rq_mov_complete = 1
  	end
  end
  
  def rq_wait(gripper_socket="1"):
      # Wait for the gripper motion to complete
      while (not rq_is_motion_complete(gripper_socket)):
  		# wait for motion completed
  		sleep(0.01)
  		sync()
  	end
  
  	# following code used for compatibility with previous versions
  	rq_is_object_detected(gripper_socket)
  
  	if (rq_obj_detect != 1):
  		rq_mov_complete = 1
  	end
  end
  
  def rq_go_to(gripper_socket="1"):
  	rq_set_var(GTO,1, gripper_socket)
  end
  
  # set the position
  def rq_set_pos(pos, gripper_socket="1"):
  	rq_set_var(POS, pos, gripper_socket)
  
  	gPRE = rq_get_var(PRE, 3, gripper_socket)
  	pre = (gPRE[1] - 48)*100 + (gPRE[2] -48)*10 + gPRE[3] - 48
  
  	while (pre != pos):
          rq_set_var(POS, pos, gripper_socket)
  		gPRE = rq_get_var(PRE, 3, gripper_socket)
  		pre = (gPRE[1] - 48)*100 + (gPRE[2] -48)*10 + gPRE[3] - 48
  		sync()
  	end
  end
  
  # set the position, speed and force
  def rq_set_pos_spd_for(pos, speed, force, gripper_socket="1"):
     rq_send_pos_spd_for(pos, speed, force, gripper_socket)
  
     ack = socket_read_byte_list(3, gripper_socket)
  
     while(is_not_ack(ack)):
        rq_send_pos_spd_for(pos, speed, force, gripper_socket)
     	  ack = socket_read_byte_list(3, gripper_socket)
     end
  end
  
  # send the position, speed and force
  def rq_send_pos_spd_for(pos, speed, force, gripper_socket="1"):
  
     socket_send_string("SET POS", gripper_socket)
     socket_send_byte(32, gripper_socket)
     socket_send_string(pos, gripper_socket)
     socket_send_byte(32, gripper_socket)
     socket_send_string("SPE", gripper_socket)
     socket_send_byte(32, gripper_socket)
     socket_send_string(speed, gripper_socket)
     socket_send_byte(32, gripper_socket)
     socket_send_string("FOR", gripper_socket)
     socket_send_byte(32, gripper_socket)
     socket_send_string(force, gripper_socket)
     socket_send_byte(10, gripper_socket)
  
  end
  
  def rq_is_motion_complete(gripper_socket="1"):
  	rq_mov_complete = 0
  
  	gOBJ = rq_get_var(OBJ, 1, gripper_socket)
  	sleep(0.01)
  
  	if (is_OBJ_gripper_at_position(gOBJ)):
  		rq_mov_complete = 1
  		return True
  	end
  
  	if (is_OBJ_object_detected(gOBJ)):
  		rq_mov_complete = 1
  		return True
  	end
  
  	return False
  
  end
  
  def rq_is_gripper_activated(gripper_socket="1"):
  	gSTA = rq_get_var(STA, 1, gripper_socket)
  
  	if(is_STA_gripper_activated(gSTA)):
  		rq_gripper_act = 1
  		return True
  	else:
  		rq_gripper_act = 0
  		return False
  	end
  end
  
  def rq_is_object_detected(gripper_socket="1"):
  	gOBJ = rq_get_var(OBJ, 1, gripper_socket)
  
  	if(is_OBJ_object_detected(gOBJ)):
  		rq_obj_detect = 1
  		return True
  	else:
  		rq_obj_detect = 0
  		return False
  	end
  end
  
  def rq_current_pos(gripper_socket="1"):
  	rq_pos = socket_get_var("POS",gripper_socket)
  	sync()
      return rq_pos
  end
  
  def rq_motor_current(gripper_socket="1"):
  	rq_current = socket_get_var("COU",gripper_socket)
  	sync()
      return rq_current * 10
  end
  
  def rq_print_gripper_fault_code(gripper_socket="1"):
  	gFLT = rq_get_var(FLT, 2, gripper_socket)
  
  	if(is_FLT_no_fault(gFLT)):
  		textmsg("Gripper Fault : ", "No Fault (0x00)")
  	elif (is_FLT_action_delayed(gFLT)):
  		textmsg("Gripper Fault : ", "Priority Fault: Action delayed, initialization must be completed prior to action (0x05)")
  	elif (is_FLT_not_activated(gFLT)):
  		textmsg("Gripper Fault : ", "Priority Fault: The activation must be set prior to action (0x07)")
  	elif (is_FLT_autorelease_in_progress(gFLT)):
  		textmsg("Gripper Fault : ", "Minor Fault: Automatic release in progress (0x0B)")
  	elif (is_FLT_overcurrent(gFLT)):
  		textmsg("Gripper Fault : ", "Minor Fault: Overcurrent protection tiggered (0x0E)")
  	elif (is_FLT_autorelease_completed(gFLT)):
  		textmsg("Gripper Fault : ", "Major Fault: Automatic release completed (0x0F)")
  	else:
  		textmsg("Gripper Fault : ", "Unkwown Fault")
  	end
  end
  
  def rq_print_gripper_num_cycles(gripper_socket="1"):
  	socket_send_string("GET NCY",gripper_socket)
  	sync()
  	string_from_server = socket_read_string(gripper_socket)
  	sync()
  
  	if(string_from_server == "0"):
  		textmsg("Gripper Cycle Number : ", "Number of cycles is unreachable.")
  	else:
  		textmsg("Gripper Cycle Number : ", string_from_server)
  	end
  end
  
  def rq_print_gripper_driver_state(gripper_socket="1"):
  	socket_send_string("GET DST",gripper_socket)
  	sync()
  	string_from_server = socket_read_string(gripper_socket)
  	sync()
  
  	if(string_from_server == "0"):
  		textmsg("Gripper Driver State : ", "RQ_STATE_INIT")
  	elif(string_from_server == "1"):
  		textmsg("Gripper Driver State : ", "RQ_STATE_LISTEN")
  	elif(string_from_server == "2"):
  		textmsg("Gripper Driver State : ", "RQ_STATE_READ_INFO")
  	elif(string_from_server == "3"):
  		textmsg("Gripper Driver State : ", "RQ_STATE_ACTIVATION")
  	else:
  		textmsg("Gripper Driver State : ", "RQ_STATE_RUN")
  	end
  end
  
  def rq_print_gripper_serial_number(gripper_socket="1"):
  	socket_send_string("GET SNU",gripper_socket)
  	sync()
  	string_from_server = socket_read_string(gripper_socket)
  	sync()
  	textmsg("Gripper Serial Number : ", string_from_server)
  end
  
  def rq_print_gripper_firmware_version(gripper_socket="1"):
  	socket_send_string("GET FWV",gripper_socket)
  	sync()
  	string_from_server = socket_read_string(gripper_socket)
  	sync()
  	textmsg("Gripper Firmware Version : ", string_from_server)
  end
  
  def rq_print_gripper_driver_version(gripper_socket="1"):
  	socket_send_string("GET VER",gripper_socket)
  	sync()
  	string_from_server = socket_read_string(gripper_socket)
  	sync()
  	textmsg("Gripper Driver Version : ", string_from_server)
  end
  
  def rq_print_gripper_probleme_connection(gripper_socket="1"):
  	socket_send_string("GET PCO",gripper_socket)
  	sync()
  	string_from_server = socket_read_string(gripper_socket)
  	sync()
  	if (string_from_server == "0"):
  		textmsg("Gripper Connection State : ", "No connection problem detected")
  	else:
  		textmsg("Gripper Connection State : ", "Connection problem detected")
  	end
  end
  
  # Returns True if list_of_bytes is [3, 'a', 'c', 'k']
  def is_ack(list_of_bytes):
  
  	# list length is not 3
  	if (list_of_bytes[0] != 3):
  		return False
  	end
  
  	# first byte not is 'a'?
  	if (list_of_bytes[1] != 97):
  		return False
  	end
  
  	# first byte not is 'c'?
  	if (list_of_bytes[2] != 99):
  		return False
  	end
  
  	# first byte not is 'k'?
  	if (list_of_bytes[3] != 107):
  		return False
  	end
  
  	return True
  end
  
  # Returns True if list_of_bytes is not [3, 'a', 'c', 'k']
  def is_not_ack(list_of_bytes):
  	if (is_ack(list_of_bytes)):
  		return False
  	else:
  		return True
  	end
  end
  
  def is_STA_gripper_activated (list_of_bytes):
  
  	# list length is not 1
  	if (list_of_bytes[0] != 1):
  		return False
  	end
  
  	# byte is '3'?
  	if (list_of_bytes[1] == 51):
  		return True
  	end
  
  	return False
  end
  
  # Returns True if list_of_byte is [1, '1'] or [1, '2']
  # Used to test OBJ = 0x1 or OBJ = 0x2
  def is_OBJ_object_detected (list_of_bytes):
  
  	# list length is not 1
  	if (list_of_bytes[0] != 1):
  		return False
  	end
  
  	# byte is '2'?
  	if (list_of_bytes[1] == 50):
  		return True
  	end
  
  	# byte is '1'?
  	if (list_of_bytes[1]  == 49):
  		return True
  	end
  
  	return False
  
  end
  
  # Returns True if list_of_byte is [1, '3']
  # Used to test OBJ = 0x3
  def is_OBJ_gripper_at_position (list_of_bytes):
  
  	# list length is not 1
  	if (list_of_bytes[0] != 1):
  		return False
  	end
  
  	# byte is '3'?
  	if (list_of_bytes[1] == 51):
  		return True
  	end
  
  	return False
  end
  
  def is_not_OBJ_gripper_at_position (list_of_bytes):
  
  	if (is_OBJ_gripper_at_position(list_of_bytes)):
  		return False
  	else:
  		return True
  	end
  end
  
  def is_FLT_no_fault(list_of_bytes):
  
  	# list length is not 2
  	if (list_of_bytes[0] != 2):
  		return False
  	end
  
  	# first byte is '0'?
  	if (list_of_bytes[1] != 48):
  		return False
  	end
  
  	# second byte is '0'?
  	if (list_of_bytes[2] != 48):
  		return False
  	end
  
  	return True
  
  end
  
  def is_FLT_action_delayed(list_of_bytes):
  
  	# list length is not 2
  	if (list_of_bytes[0] != 2):
  		return False
  	end
  
  	# first byte is '0'?
  	if (list_of_bytes[1] != 48):
  		return False
  	end
  
  	# second byte is '5'?
  	if (list_of_bytes[2] != 53):
  		return False
  	end
  
  	return True
  end
  
  def is_FLT_not_activated(list_of_bytes):
  
  	# list length is not 2
  	if (list_of_bytes[0] != 2):
  		return False
  	end
  
  	# first byte is '0'?
  	if (list_of_bytes[1] != 48):
  		return False
  	end
  
  	# second byte is '7'?
  	if (list_of_bytes[2] != 55):
  		return False
  	end
  
  	return True
  end
  
  def is_FLT_autorelease_in_progress(list_of_bytes):
  
  	# list length is not 2
  	if (list_of_bytes[0] != 2):
  		return False
  	end
  
  	# first byte is '1'?
  	if (list_of_bytes[1] != 49):
  		return False
  	end
  
  	# second byte is '1'?
  	if (list_of_bytes[2] != 49):
  		return False
  	end
  
  	return True
  
  end
  
  def is_FLT_overcurrent(list_of_bytes):
  
  	# list length is not 2
  	if (list_of_bytes[0] != 2):
  		return False
  	end
  
  	# first byte is '1'?
  	if (list_of_bytes[1] != 49):
  		return False
  	end
  
  	# second byte is '4'?
  	if (list_of_bytes[2] != 52):
  		return False
  	end
  
  	return True
  
  end
  
  def is_FLT_autorelease_completed(list_of_bytes):
  
  	# list length is not 2
  	if (list_of_bytes[0] != 2):
  		return False
  	end
  
  	# first byte is '1'?
  	if (list_of_bytes[1] != 49):
  		return False
  	end
  
  	# second byte is '5'?
  	if (list_of_bytes[2] != 53):
  		return False
  	end
  
  	return True
  
  end
  
  def rq_set_var(var_name, var_value, gripper_socket="1"):
  
  	sync()
  	if (var_name == ACT):
  		socket_set_var("ACT", var_value, gripper_socket)
  	elif (var_name == GTO):
  		socket_set_var("GTO", var_value, gripper_socket)
  	elif (var_name == ATR):
  		socket_set_var("ATR", var_value, gripper_socket)
  	elif (var_name == ARD):
  		socket_set_var("ARD", var_value, gripper_socket)
  	elif (var_name == FOR):
  		socket_set_var("FOR", var_value, gripper_socket)
  	elif (var_name == SPE):
  		socket_set_var("SPE", var_value, gripper_socket)
  	elif (var_name == POS):
  		socket_set_var("POS", var_value, gripper_socket)
  	else:
  	end
  
      sync()
  
  	ack = socket_read_byte_list(3, gripper_socket)
  
  	sync()
  
  	while(is_not_ack(ack)):
  		textmsg("Retry in rq_set_var")
  
  		textmsg("rq_set_var : retry", " ...")
  		textmsg("rq_set_var : var_name = ", var_name)
  		textmsg("rq_set_var : var_value = ", var_value)
  
  		if (ack[0] != 0):
  			textmsg("rq_set_var : invalid ack value = ", ack)
  		end
  
  		socket_set_var(var_name , var_value,gripper_socket)
  		sync()
  		ack = socket_read_byte_list(3, gripper_socket)
  		sync()
  	end
  end
  
  
  def rq_get_var(var_name, nbr_bytes, gripper_socket="1"):
  
  	if (var_name == FLT):
  		socket_send_string("GET FLT",gripper_socket)
  		sync()
  	elif (var_name == OBJ):
  		socket_send_string("GET OBJ",gripper_socket)
  		sync()
  	elif (var_name == STA):
  		socket_send_string("GET STA",gripper_socket)
  		sync()
  	elif (var_name == PRE):
  		socket_send_string("GET PRE",gripper_socket)
  		sync()
  	else:
  	end
  
  	var_value = socket_read_byte_list(nbr_bytes, gripper_socket)
  	sync()
  
  	return var_value
  end
  
  def rq_is_object_validated(gripper_selected, gripper_socket="1"):
  	if(gripper_selected):
  		if(rq_is_object_detected(gripper_socket)):
  		    return True
  		else:
  		    return False
  		end
  	else:
  		return True
  	end
  end
  
  ############################################
  # normalized functions (maps 0-100 to 0-255)
  ############################################
  def rq_set_force_norm(force_norm, gripper_socket="1"):
      force_gripper = norm_to_gripper(force_norm)
      rq_set_force(force_gripper, gripper_socket)
  end
  
  def rq_set_speed_norm(speed_norm, gripper_socket="1"):
      speed_gripper = norm_to_gripper(speed_norm)
      rq_set_speed(speed_gripper, gripper_socket)
  end
  
  def rq_move_norm(pos_norm, gripper_socket="1"):
      pos_gripper = norm_to_gripper(pos_norm)
      rq_move(pos_gripper, gripper_socket)
  end
  
  def rq_move_and_wait_norm(pos_norm, gripper_socket="1"):
      pos_gripper = norm_to_gripper(pos_norm)
      rq_move_and_wait(pos_gripper, gripper_socket)
  end
  
  def rq_set_pos_norm(pos_norm, gripper_socket="1"):
      pos_gripper = norm_to_gripper(pos_norm)
      rq_set_pos(pos_gripper, gripper_socket)
  end
  
  
  def rq_current_pos_norm(gripper_socket="1"):
      pos_gripper = rq_current_pos(gripper_socket)
      pos_norm = gripper_to_norm(pos_gripper)
      return pos_norm
  end
  
  def gripper_to_norm(value_gripper):
      value_norm = (value_gripper / 255) * 100
      return floor(value_norm)
  end
  
  def norm_to_gripper(value_norm):
      value_gripper = (value_norm / 100) * 255
      return ceil(value_gripper)
  end
  
  def rq_get_position():
      return rq_current_pos_norm()
  end
  ############################################
  # mm/inches functions
  ############################################
  gripper_closed_norm = [100, 100, 100, 100]
  gripper_open_norm = [0, 0, 0, 0]
  gripper_closed_mm = [0, 0, 0, 0]
  gripper_open_mm = [50, 50, 50, 50]
  
  def rq_current_pos_mm(gripper_socket=1):
      pos_gripper = rq_current_pos(gripper_socket)
      pos_mm = gripper_to_mm(pos_gripper, gripper_socket)
      return round_value_2_dec(pos_mm)
  end
  
  def rq_current_pos_inches(gripper_socket=1):
      pos_gripper = rq_current_pos(gripper_socket)
      pos_mm = gripper_to_mm(pos_gripper, gripper_socket)
      pos_in = pos_mm / 25.4
      return round_value_2_dec(pos_in)
  end
  
  def get_closed_norm(gripper_socket):
      return gripper_closed_norm[gripper_socket - 1]
  end
  
  def get_open_norm(gripper_socket):
      return gripper_open_norm[gripper_socket - 1]
  end
  
  def get_closed_mm(gripper_socket):
      return gripper_closed_mm[gripper_socket - 1]
  end
  
  def get_open_mm(gripper_socket):
      return gripper_open_mm[gripper_socket - 1]
  end
  
  def set_closed_norm(closed_norm, gripper_socket):
      gripper_closed_norm[gripper_socket - 1] = closed_norm
  end
  
  def set_open_norm(open_norm, gripper_socket):
      gripper_open_norm[gripper_socket - 1] = open_norm
  end
  
  def set_closed_mm(closed_mm, gripper_socket):
      gripper_closed_mm[gripper_socket - 1] = closed_mm
  end
  
  def set_open_mm(open_mm, gripper_socket):
      gripper_open_mm[gripper_socket - 1] = open_mm
  end
  
  def gripper_to_mm(value_gripper, gripper_socket):
      closed_norm = get_closed_norm(gripper_socket)
      open_norm = get_open_norm(gripper_socket)
      closed_mm = get_closed_mm(gripper_socket)
      open_mm = get_open_mm(gripper_socket)
  
      value_norm = (value_gripper / 255) * 100
  
      slope = (closed_mm - open_mm) / (closed_norm - open_norm)
      value_mm = slope * (value_norm - closed_norm) + closed_mm
  
      if (value_mm > open_mm):
      	value_mm_limited = open_mm
      elif (value_mm < closed_mm):
      	value_mm_limited = closed_mm
      else:
          value_mm_limited = value_mm
      end
  
      return value_mm_limited
  end
  
  def round_value(value):
      value_mod = value % 1
  
  	if(value_mod < 0.5):
  		return floor(value)
  	else:
  		return ceil(value)
  	end
  end
  
  def round_value_2_dec(value):
      value_x_100 = value * 100
      value_x_100_rounded = round_value(value_x_100)
      return value_x_100_rounded / 100
  end
  #########################################
  
  
  rq_obj_detect = 0
  rq_init_connection(9, "1")
  connectivity_checked = [-1,-1,-1,-1]
  status_checked = [-1,-1,-1,-1]
  current_speed = [-1,-1,-1,-1]
  current_force = [-1,-1,-1,-1]
  set_closed_norm(100.0,1)
  set_open_norm(0.0, 1)
  set_closed_mm(0.0, 1)
  set_open_mm(50.0, 1)
  set_closed_norm(100.0,2)
  set_open_norm(0.0, 2)
  set_closed_mm(0.0, 2)
  set_open_mm(50.0, 2)
  set_closed_norm(100.0,3)
  set_open_norm(0.0, 3)
  set_closed_mm(0.0, 3)
  set_open_mm(50.0, 3)
  set_closed_norm(100.0,4)
  set_open_norm(0.0, 4)
  set_closed_mm(0.0, 4)
  set_open_mm(50.0, 4)
  
  #######Gripper URCap preamble end##########
  ###########################################
  
  # end: URCap Installation Node
  $ 6 "Thread_1"
  thread Thread_1():
    while (True):
      sync()
      write_output_float_register(1, Fx)
    end
  end
  threadId_Thread_1 = run Thread_1()
  while (True):
    $ 1 "Robot Program"
    $ 2 "write_output_integer_register(1,1)"
    write_output_integer_register(1,1)
    # begin: URCap Program Node
    #   Source: Robotiq_Grippers, 1.3.0, Robotiq Inc.
    #   Type: Gripper
    $ 3 "Gripper Close (1)"
    gripper_1_used = True
    if (connectivity_checked[0] != 1):
      if not(rq_set_sid(9, "1")):
        popup("Gripper 1 must be connected to run this program.", "No connection", False, True, True)
      end
      connectivity_checked[0] = 1
    end
    if (status_checked[0] != 1):
      if not(rq_is_gripper_activated("1")):
        popup("Gripper 1 is not activated. Go to Installation tab > Gripper to activate it and run the program again.", "Not activated", False, True, True)
      end
      status_checked[0] = 1
    end
    rq_set_speed(255, "1")
    current_speed[0] = 255
    rq_set_force(255, "1")
    current_force[0] = 255
    rq_set_pos(255, "1")
    rq_go_to("1")
    rq_wait("1")
    gripper_1_selected = True
    gripper_2_selected = False
    gripper_3_selected = False
    gripper_4_selected = False
    gripper_1_used = False
    gripper_2_used = False
    gripper_3_used = False
    gripper_4_used = False
    # end: URCap Program Node
    $ 4 "write_output_integer_register(1,0)"
    write_output_integer_register(1,0)
    # begin: URCap Program Node
    #   Source: Robotiq_Grippers, 1.3.0, Robotiq Inc.
    #   Type: Gripper
    $ 5 "Gripper Open (1)"
    gripper_1_used = True
    if (connectivity_checked[0] != 1):
      if not(rq_set_sid(9, "1")):
        popup("Gripper 1 must be connected to run this program.", "No connection", False, True, True)
      end
      connectivity_checked[0] = 1
    end
    if (status_checked[0] != 1):
      if not(rq_is_gripper_activated("1")):
        popup("Gripper 1 is not activated. Go to Installation tab > Gripper to activate it and run the program again.", "Not activated", False, True, True)
      end
      status_checked[0] = 1
    end
    rq_set_speed(255, "1")
    current_speed[0] = 255
    rq_set_force(255, "1")
    current_force[0] = 255
    rq_set_pos(0, "1")
    rq_go_to("1")
    rq_wait("1")
    gripper_1_selected = True
    gripper_2_selected = False
    gripper_3_selected = False
    gripper_4_selected = False
    gripper_1_used = False
    gripper_2_used = False
    gripper_3_used = False
    gripper_4_used = False
    # end: URCap Program Node
  end
end
